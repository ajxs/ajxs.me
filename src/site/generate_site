#!/usr/bin/env python3

"""
Generates all of the static content for the site, as part of the full deployment artefact.
This script generates all of the page content from the blog SQLite database.
"""

from datetime import datetime
from string import Template
import os
import sqlite3

__author__ = "AJXS"
__copyright__ = "Copyright 2020, AJXS"
__credits__ = ["AJXS"]
__license__ = "GPL"
__version__ = "1.0"
__maintainer__ = "AJXS"
__email__ = "ajxs at panoptic.online"
__status__ = "Production"


# The destination folder for the distributable artifacts.
DIST_FOLDER = "{}/dist".format(os.getcwd())
# The base template folder.
TEMPLATE_FOLDER = f"{os.getcwd()}/src/site/template"
# The destination folder for generated blog entries.
DIST_BLOG_ENTRIES_FOLDER = DIST_FOLDER + "/blog"
# The main database file.
DATABASE_FILE = "{}/blog.sqlite3".format(os.getcwd())

# The database query to load all blog entries.
LOAD_ENTRIES_QUERY = """
SELECT *
FROM entry e
WHERE e.date_deleted IS NULL
ORDER BY e.date_created DESC;
"""

# Database query used to load the tags for an individual entry.
LOAD_ENTRY_TAGS_QUERY = """
SELECT t.* FROM tagged_entry k
LEFT JOIN tag t ON t.tag_id = k.tag_id
WHERE k.entry_id = ?;
"""

# Database query used to load the tags.
LOAD_TAGS_QUERY = """
SELECT t.*
FROM tag t
WHERE t.date_deleted IS NULL;
"""

# Database query used to load the entries associated with a tag.
LOAD_TAGGED_ENTRIES_QUERY = """
SELECT e.*
FROM tagged_entry k
LEFT JOIN entry e ON e.entry_id = k.entry_id
WHERE k.tag_id = ?
AND e.date_deleted IS NULL
ORDER BY e.date_created DESC;
"""

# The blog entry template.
BLOG_ENTRY_TEMPLATE = None
# Template for the tags in the blog entry header.
BLOG_ENTRY_TAGS_TEMPLATE = None
# Blog entry index link template.
BLOG_ENTRY_INDEX_TEMPLATE = None
# Blog entry index link tags template.
BLOG_ENTRY_INDEX_TAGS_TEMPLATE = None
# The main site index template.
INDEX_TEMPLATE = None
# The main page template.
MAIN_PAGE_TEMPLATE = None
# The index template for a particular tag.
TAG_INDEX_TEMPLATE = None

# Open and parse each of the template HTML files.
with open(f"{TEMPLATE_FOLDER}/entry.html", mode='r') as template_file:
    BLOG_ENTRY_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/entry_tags.html", mode='r') as template_file:
    BLOG_ENTRY_TAGS_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/index.html", mode='r') as template_file:
    INDEX_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/index_entry.html", mode='r') as template_file:
    BLOG_ENTRY_INDEX_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/index_entry_tags.html", mode='r') as template_file:
    BLOG_ENTRY_INDEX_TAGS_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/main_page.html", mode='r') as template_file:
    MAIN_PAGE_TEMPLATE = Template(template_file.read())

with open(f"{TEMPLATE_FOLDER}/tag_index.html", mode='r') as template_file:
    TAG_INDEX_TEMPLATE = Template(template_file.read())


def normalise_entry_name(tag_name):
    """
    Creates a filename from an entry or tag name.
    """

    filename = tag_name.replace(" ", "_")
    filename = filename.replace("?", "")
    filename = filename.replace(".", "")
    filename = filename.replace(",", "")

    return filename


def load_tags():
    """
    Loads all tags from the database.
    """

    tags = []

    with sqlite3.connect(DATABASE_FILE) as conn:
        # The cursor used to fetch tags.
        tag_cursor = conn.cursor()

        tag_cursor.execute(LOAD_TAGS_QUERY)

        # Fetch all entry rows.
        while True:
            tag_rows = tag_cursor.fetchmany()
            # Break if all rows read.
            if not tag_rows:
                break

            for tag_row in tag_rows:
                tags.append({
                    "tag_id": tag_row[0],
                    "name": tag_row[1]
                })

    return tags


def parse_entry_row(entry_row):
    """
    Parses an individual entry row into the correct format.
    """

    # The parsed creation and modification dates.
    date_created = datetime.strptime(entry_row[4], "%Y-%m-%d %H:%M:%S").strftime("%Y.%m.%d")
    date_modified = datetime.strptime(entry_row[5], "%Y-%m-%d %H:%M:%S").strftime("%Y.%m.%d")

    # The date the entry was deleted, if present.
    date_deleted = None
    if entry_row[6] is not None:
        date_deleted = datetime.strptime(entry_row[6], "%Y-%m-%d %H:%M:%S").strftime("%Y.%m.%d")

    # The final filename for the entry.
    entry_filename = normalise_entry_name(entry_row[1])

    return {
        "entry_id": entry_row[0],
        "title": entry_row[1],
        "short": entry_row[2],
        "body": entry_row[3],
        "date_created": date_created,
        "date_modified": date_modified,
        "date_deleted": date_deleted,
        "filename": entry_filename,
        "tags": []
    }


def load_blog_entries():
    """
    Loads all of the entries from the database.
    """

    # The full array of blog entries which will be returned.
    blog_entries = []

    with sqlite3.connect(DATABASE_FILE) as conn:
        # The cursor used to fetch entries.
        entry_cursor = conn.cursor()

        # The cursor used to fetch the entries.
        entry_cursor.execute(LOAD_ENTRIES_QUERY)

        # Fetch all entry rows.
        while True:
            entry_rows = entry_cursor.fetchmany()
            # Break if all rows read.
            if not entry_rows:
                break

            for entry_row in entry_rows:
                # List of tags applied to this entry.
                entry_tags = []

                # Cursor used to fetch tags.
                tag_cursor = conn.cursor()

                # Fetch all post tags applied to this post.
                tag_cursor.execute(LOAD_ENTRY_TAGS_QUERY, (entry_row[0], ))

                # Iterate through all tag rows.
                while True:
                    tag_rows = tag_cursor.fetchmany()
                    # Break if all rows read.
                    if not tag_rows:
                        break

                    for tag_row in tag_rows:
                        entry_tags.append({
                            "tag_id": tag_row[0],
                            "name": tag_row[1]
                        })

                # Parse the entry row.
                parsed_entry_row = parse_entry_row(entry_row)
                parsed_entry_row["tags"] = entry_tags

                blog_entries.append(parsed_entry_row)

    return blog_entries


def create_blog_entry_file(entry):
    """
    Creates an individual blog entry HTML file from a parsed entry.
    """

    # Fail if the template has not been loaded.
    if BLOG_ENTRY_TEMPLATE is None or BLOG_ENTRY_TAGS_TEMPLATE is None:
        raise ValueError("Blog entry templates are not loaded")

    # The HTML to display the entry tags.
    entry_tag_list_html = ""
    # The HTML to display the entry tag list.
    entry_tags_html = ""
    # The full page HTML. This is the Index HTML baked in to the main page template.
    full_file_html = ""

    # If there are tags in this entry, create the tag HTML.
    if entry["tags"]:
        for tag in entry["tags"]:
            tag_filename = normalise_entry_name(tag["name"])

            entry_tag_list_html += "<li><a href=\"{}\">{}</a></li>".format(
                "/blog/tag/{}".format(tag_filename),
                tag["name"]
            )

        entry_tags_html = BLOG_ENTRY_TAGS_TEMPLATE.substitute(
            entry_tag_list=entry_tag_list_html
        )

    # The final resulting entry HTML.
    entry_html = BLOG_ENTRY_TEMPLATE.substitute(
        title=entry["title"],
        date=entry["date_created"],
        short=entry["short"],
        entry_body=entry["body"],
        entry_tags=entry_tags_html
    )

    # Create the full page HTML.
    full_file_html = MAIN_PAGE_TEMPLATE.substitute(
        page_title="panoptic.online/{}".format(entry["title"]),
        page_html=entry_html
    )

    # The final filename for the blog entry HTML.
    blog_entry_filename = "{}/{}.html".format(DIST_BLOG_ENTRIES_FOLDER, entry["filename"])
    with open(blog_entry_filename, 'x') as blog_entry_file:
        blog_entry_file.write(full_file_html)

    print("Wrote blog entry file: {}".format(blog_entry_filename))


def create_tag_pages():
    """
    Creates all of the individual tag index pages.
    """

    # Fail if the template has not been loaded.
    if TAG_INDEX_TEMPLATE is None or INDEX_TEMPLATE is None:
        raise ValueError("Templates are not loaded")

    # All of the tags used in the blog.
    tags = load_tags()

    with sqlite3.connect(DATABASE_FILE) as conn:
        # The cursor used to fetch entries.
        entry_cursor = conn.cursor()

        for tag in tags:
            # All of the entries tagged with this specific tag.
            tagged_entries = []
            # The filename for this tag.
            tag_filename = normalise_entry_name(tag["name"])
            # The HTML for the blog entries in the index.
            index_entries_html = ""

            entry_cursor.execute(LOAD_TAGGED_ENTRIES_QUERY, (tag["tag_id"],))

            # Iterate through all tag rows.
            while True:
                entry_rows = entry_cursor.fetchmany()
                # Break if all rows read.
                if not entry_rows:
                    break

                for entry_row in entry_rows:
                    parsed_entry_row = parse_entry_row(entry_row)
                    tagged_entries.append(parsed_entry_row)

            for entry in tagged_entries:
                # For each entry generate the blog entry HTML and add this to the index
                # entries HTML string.
                index_entries_html += BLOG_ENTRY_INDEX_TEMPLATE.substitute(
                    entry_link="/blog/{}".format(entry["filename"]),
                    date=entry["date_created"],
                    title=entry["title"],
                    short=entry["short"],
                    entry_tags=""
                )

            # Create the index HTML.
            index_html = TAG_INDEX_TEMPLATE.substitute(
                tag_name=tag["name"],
                tagged_entries=index_entries_html
            )

            # The full page HTML. This is the Index HTML baked in to the main page template.
            full_file_html = MAIN_PAGE_TEMPLATE.substitute(
                page_title="panoptic.online/{}".format(tag["name"]),
                page_html=index_html
            )

            # The final filename of the tag index HTML file.
            tag_index_filename = "{}/blog/tag/{}.html".format(DIST_FOLDER, tag_filename)
            with open(tag_index_filename, 'x') as index_file:
                index_file.write(full_file_html)

            print("Wrote tag index file: {}".format(tag_index_filename))


def create_index(entries):
    """
    Creates the site index.
    """

    # Fail if the required templates have not been loaded.
    if BLOG_ENTRY_INDEX_TEMPLATE is None or INDEX_TEMPLATE is None:
        raise ValueError("Templates are not loaded")

    # The HTML for the blog entries in the index.
    index_entries_html = ""
    # The HTML for the site index.
    index_html = ""

    for entry in entries:
        # The link to the blog entry.
        entry_link = "/blog/{}".format(entry["filename"])
        # The HTML to display the entry tags.
        entry_tag_list_html = ""
        # The HTML to display the entry tag list.
        entry_tags_html = ""

        # If there are tags in this entry, create the tag HTML.
        if entry["tags"]:
            for tag in entry["tags"]:
                # The filename for this tag.
                tag_filename = normalise_entry_name(tag["name"])

                entry_tag_list_html += "<li><a href=\"{}\">{}</a></li>".format(
                    "/blog/tag/{}".format(tag_filename),
                    tag["name"]
                )

            entry_tags_html = BLOG_ENTRY_INDEX_TAGS_TEMPLATE.substitute(
                entry_tag_list=entry_tag_list_html
            )

        # For each entry generate the blog entry HTML and add this to the index entries
        # HTML string.
        index_entries_html += BLOG_ENTRY_INDEX_TEMPLATE.substitute(
            entry_link=entry_link,
            date=entry["date_created"],
            title=entry["title"],
            short=entry["short"],
            entry_tags=entry_tags_html
        )

    # Create the index HTML.
    index_html = INDEX_TEMPLATE.substitute(blog_entries=index_entries_html)

    # The full page HTML. This is the Index HTML baked in to the main page template.
    full_file_html = MAIN_PAGE_TEMPLATE.substitute(
        page_title="panoptic.online",
        page_html=index_html
    )

    with open("{}/index.html".format(DIST_FOLDER), 'x') as index_file:
        index_file.write(full_file_html)

    print("Wrote index.html")


def main():
    """
    Main program.
    """

    # Load all of the individual blog entries from the database.
    blog_entries = load_blog_entries()

    # Create all of the individual blog entry files.
    for entry in blog_entries:
        create_blog_entry_file(entry)

    # Creates the tag index pages.
    create_tag_pages()

    # Creates the site index.
    create_index(blog_entries)


if __name__ == "__main__":
    main()
