<!DOCTYPE html>
<html lang="en">
	<head>
				<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="author" content="ajxs">
		<meta name="description" content="An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.">
		<meta name="robots" content="index, follow">
		<meta name="keywords" content="ajxs,synthesisers,programming,dsp,Programming">
		<meta name="reply-to" content="ajxs@panoptic.online">
		<meta name="owner" content="ajxs">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" type="text/css" href="/static/style.css">
		<link rel="stylesheet" type="text/css" href="/static/code.css">
		<link rel="alternate" type="application/rss+xml" title="Blog Posts" href="/site.rss">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/img/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicon-16x16.png">

		<title>~ajxs/Giving Ada a Chance</title>
				
	</head>
	<body>
		<header>
			<a href="/">~ajxs</a>
		</header>
		<article class="blog-entry">
	<header>
		<h1>Giving Ada a Chance</h1>
		<div class="date">2021.01.13</div>
		<div class="short">An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.</div>
							<div class="tags">
				<span>Tagged as: </span>
				<ul class="tag-list">
							<li><a href="/blog/tag/Programming.html">Programming</a></li>
					</ul>
			</div>
			</header>
	<div class="entry-body">
		<div class="tldr">
	<span class="tldr-heading">TL;DR:</span>
	Ada is an extremely interesting and robust programming language that has a lot to offer modern developers of system and bare-metal software. 
	At very least, Ada presents many interesting ideas that designers of modern programming languages could stand to learn much from. 
	If you want a 30 second version of this article, 
	check out the <a href="#practical_example">practical example</a> that I provide for a comparison of Ada with C.
</div>
<p>
	<b>Update October 2022:</b>
	After receiving some fantastic correspondence from experienced Ada developers,
	I've made some amendments to this article to correct some factual errors, remove some unsubstantiated conjecture,
	and improve the general quality of the writing.
</p>
<p>
	Much of the technical material presented in this article is available as part of
	<a href="https://wiki.osdev.org/User:Ajxs" target="_blank">my contributions</a> to 
	<a href="https://wiki.osdev.org/Main_Page" target="_blank">osdev.org</a>
</p>
<p>
	I consider myself a rational man. 
	While I may believe in an entirely deterministic model of the universe, 
	I do not believe it to be guided by any conscious process.
	I don't believe in destiny. 
	This absence of guidance makes such fortuitous occurrences as the one I will discuss all the more extraordinary, 
	and for this I am all the more grateful.
</p>

<h2 id="a_chance_collision">A Chance Collision <a class="permalink" href="#a_chance_collision">#</a></h2>
<p>
	By no deliberate design of my own, I happen to live close to a university. 
	Not in the kind of 'University town' common to much of Europe or the United States, 
	but in the densely packed suburban sprawl of Sydney's inner-city. 
	My regular walk to and from the local shopping centre takes me past several of the buildings belonging to the highly regarded engineering faculty of the aforementioned University.
</p>
<p>
	Making my way home one serendipitous afternoon, 
	I happened across a sizeable stack of books sitting on the curb outside one of the University's engineering buildings. 
	The university was ostensibly in the process of liquidating its stockpile of old engineering books, 
	and had left them in a pile for the local council to collect. 
	Amongst material covering a wide variety of academic disciplines, 
	two books in particular caught my eye: <i>Building Parallel, Embedded, and Real-Time Applications with Ada</i>, 
	and <i>Concurrent and Real-Time Programming in Ada</i>.
</p>
<p>
	I had heard of Ada before. I understood that it came from a pedigree of languages developed for the United States military, 
	and that it still occupied a niche in the development of safety-critical applications, nothing more.
	Curious, I threw the books in my bag and off I went.
</p>


<h2 id="exceeding my_expectations">Exceeding My Expectations <a class="permalink" href="#exceeding my_expectations">#</a></h2>
<p>
	Admittedly, I had pictured Ada's syntax resembling the uncompromising verbosity and rigid construction of COBOL, 
	or perhaps the Lovecraftian hieroglyphics of APL's various eldritch incarnations. 
	Turning the pages, I was pleasantly surprised by modern constructs associated with modern high-level languages such as ranges, 
	slicing, and exception-handling.
	The syntax &#8212;Admittedly verbose by modern standards<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>&#8212; 
	seemed deliberately and purposefully constructed to make the language comprehensible at a glance.
</p>
<p>
	The fact that Ada was designed with embedded software in mind was of particular interest to me. 
	I already had some limited experience with bare-metal development on the x86 and ARM platforms using C and assembly, 
	so the prospect of using higher-level constructs on bare-metal seemed promising to me.
</p>

<h2 id="not_the_camel_you_expected">Not the Camel You Expected <a class="permalink" href="#not_the_camel_you_expected">#</a></h2>
<p>
	A common pejorative refrain directed at Ada by its many detractors is that it is a language "designed by committee",
	or even worse, a language "designed by committee <i>for the military</i>"<sup><a href="#footnote_2" id="footnote_2_link">2</a></sup>. 
	The implication of which being that this would preclude it from having any kind of real-world practicality. 
	I contend that it is better to design a language to fit an existing problem domain than to pick your weapon of choice and set out in search of new problem domains to apply it to<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>. 
	I will spare readers a detailed retelling of Ada's conception within the Department of Defense's <a href="http://archive.adaic.com/pol-hist/history/holwg-93/holwg-93.htm" target="_blank">'High Order Language Working Group'</a>, 
	save to say that the Ada programming language was born of the need for single, unified higher-level language suitable for use in the multitude of real-time embedded systems developed by the DoD<sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>. 
	In the wise words of the working-group's chair, Colonel William A. Whitaker: 
	<i>"It was concluded that no existing language could be adopted as a single common high order language for the DoD, 
	but that a single language meeting essentially all the requirements was both feasible and desirable."</i>. 
	If such a thing was indeed feasible, the DoD's deep pockets would help it bring it into existence. 
	Ironically, given its status as the de-facto standard language of modern embedded-system development, 
	the C language was considered unsuitable for this purpose: 
	<i>"When Bell Labs were invited to evaluate C against the DoD requirements, 
	they said that there was no chance of C meeting the requirements of readability, safety, etc."</i> (Whitaker, 1993). 
	In what would prove a controversial decision, 
	the DoD would go so far as to mandate the use of Ada for <i>all</i> in-house software engineering.
</p>

<h2 id="what_makes_it_so_good">So What Makes It Special? <a class="permalink" href="#what_makes_it_so_good">#</a></h2>
<p>
	Ada has many useful features that are of particular interest for low-level programming and operating-system development. 
	One feature in particular that impressed me greatly was Ada's <i>representation clauses</i> (see below). 
	They provide a method for defining the in-memory representation of low-level data structures. 
	I was very quickly able to adapt my own long suffering operating-system development projects to Ada, 
	improving the quality of my codebase greatly in the process. 
	The following section details some of Ada's features:
</p>

<h3>Custom Types</h3>
<p>
	In addition to being a strongly typed language, 
	Ada allows for the definition of new scalar, enumerated, and record types.
	Custom primitive types can also be constrained to a predefined range of values.
	The example below demonstrates the definition of a new integer type based upon Ada's native <code>Natural</code> type,
	restricted to a predefined range.
	The use of the subtype directive informs the compiler that other variables of the <code>Natural</code> type are compatible with the newly defined subtype.
</p>

<div class="code-block">
	<pre><span/><span class="no">VGA_COL_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">80</span><span class="p">;</span>
<span class="no">VGA_ROW_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">24</span><span class="p">;</span>

<span class="kd">subtype</span> <span class="kt">Col</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_COL_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">Row</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_ROW_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</pre>
</div>

<p>
	The below example illustrates the creation of incompatible custom integer types. 
	While their base type and range constraints are identical, Ada treats both as separate, incompatible types. 
	An assignment of a variable of one type to the value of another is illegal, and will trigger a compile-time error.
</p>

<div class="code-block">
	<pre><span/><span class="kd">type</span> <span class="kt">Integer_1</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Integer_2</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">A</span> <span class="p">:</span> <span class="n">Integer_1</span> <span class="p">:=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">B</span> <span class="p">:</span> <span class="n">Integer_2</span> <span class="p">:=</span> <span class="n">A</span><span class="p">;</span> <span class="c1">-- illegal!</span>
</pre>
</div>

<p>
	The following example demonstrates the creation of a custom enumerated type. 
	It also demonstrates a subtype of an enumerated type with a constrained range of values.
</p>

<div class="code-block">
	<pre><span/><span class="kd">type</span> <span class="kt">Day_Of_Week</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Monday</span><span class="p">,</span> <span class="nv">Tuesday</span><span class="p">,</span>
  <span class="nv">Wednesday</span><span class="p">,</span> <span class="nv">Thursday</span><span class="p">,</span> <span class="nv">Friday</span><span class="p">,</span> <span class="nv">Saturday</span><span class="p">,</span> <span class="nv">Sunday</span><span class="p">);</span>

<span class="kd">subtype</span> <span class="kt">Work_Day</span> <span class="kr">is</span> <span class="n">Day_Of_Week</span> <span class="kr">range</span> <span class="n">Monday</span> <span class="p">..</span> <span class="n">Friday</span><span class="p">;</span>
</pre>
</div>


<p>
	A variable with the type of <code>Work_Day</code> is restricted to its constrained range. 
	Any attempt to assign a value outside of this range to a variable of this type will raise a <code>Constraint_Error</code> exception at runtime.
</p>

<h3>Representation Clauses</h3>
<p>
	Ada allows for explicitly defining the in-memory representation of scalar and compound types. The following example
	demonstrates the definition of a record type (equivalent to structures in C), as well as its associated
	representation in memory.
</p>

<div class="code-block">
	<pre><span/><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The format of the System Table Descriptor pointer used by the processor</span>
<span class="c1">--  to load descriptor tables like the GDT and IDT.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">System_Table_Descriptor</span> <span class="kr">is</span>
   <span class="kr">record</span>
      <span class="n">Size</span>   <span class="p">:</span> <span class="n">Unsigned_16</span><span class="p">;</span>
      <span class="n">Offset</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span><span class="p">;</span>
   <span class="kr">end record</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">48</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">System_Table_Descriptor</span> <span class="kn">use</span>
   <span class="nn">record</span>
      <span class="n">Size</span>   <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span>  <span class="p">..</span> <span class="mi">15</span><span class="p">;</span>
      <span class="n">Offset</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">16</span> <span class="p">..</span> <span class="mi">47</span><span class="p">;</span>
   <span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>
</pre>
</div>

<p>
	The <code>Size</code> aspect specifier instructs the compiler that the <code>System_Table_Descriptor</code> type must be 48 bits in size. 
	The record representation clause instructs the compiler as to the required layout of this record type in memory. 
	This example specifies that the <code>Size</code> member should occupy bits 0 to 15, 
	and the <code>Offset</code> member should occupy bits 16 to 47. 
	This feature is analogous to C's bit-fields. 
	The following example demonstrates defining the in-memory representation of an enumerated type.
</p>

<div class="code-block">
	<pre><span/><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The privilege level for a particular descriptor.</span>
<span class="c1">--  These correspond to the 'protection ring' that this descriptor is</span>
<span class="c1">--  accessible from.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">Descriptor_Privilege_Level</span> <span class="kr">is</span> <span class="p">(</span>
   <span class="nv">Ring_0</span><span class="p">,</span>
   <span class="nv">Ring_1</span><span class="p">,</span>
   <span class="nv">Ring_2</span><span class="p">,</span>
   <span class="nv">Ring_3</span>
<span class="p">)</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">Descriptor_Privilege_Level</span> <span class="kn">use</span> <span class="p">(</span>
   <span class="n">Ring_0</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">Ring_1</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Ring_2</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Ring_3</span> <span class="p">=&gt;</span> <span class="mi">3</span>
<span class="p">);</span>
</pre>
</div>


<p>
	The <code>Size</code> aspect specifier instructs the compiler that the <code>Descriptor_Privilege_Level</code> type must be 2 bits in size.
	The representation clause instructs the compiler as to required representation of each possible value of the enumerated type in memory. 
	In this example the value of <code>Ring_0</code> will be represented by a value of <code>0x0</code> in memory,
	the value of <code>Ring_1</code> will be represented by <code>0x1</code>, and so on.
</p>

<h2 id="practical_example">A Practical Example <a class="permalink" href="#practical_example">#</a></h2>
<p>
	The following example, and accompanying comparison with C, demonstrates the configuration of a hypothetical UART device by interfacing with an 8-bit memory-mapped configuration register.
	This example has been adapted from a presentation by AdaCore viewable <a href="https://www.youtube.com/watch?v=qvmDqbuQe-M" target="_blank">here</a>.
</p>

<div class="code-block">
	<pre><span/><span class="kn">with</span> <span class="nn">System.Storage_Elements</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">System.Storage_Elements</span><span class="p">;</span>

<span class="c1">-------------------------------------------------------------------------------</span>
<span class="c1">--  Main</span>
<span class="c1">-------------------------------------------------------------------------------</span>
<span class="kd">procedure</span> <span class="nf">Main</span> <span class="kr">is</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Baud rate type.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Baud_Rate_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">b_9600</span><span class="p">,</span> <span class="nv">b_14400</span><span class="p">,</span> <span class="nv">b_115200</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Baud_Rate_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">b_9600</span>   <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">b_14400</span>  <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">b_115200</span> <span class="p">=&gt;</span> <span class="mi">7</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Parity Select Type</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Parity_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">None</span><span class="p">,</span> <span class="nv">Even</span><span class="p">,</span> <span class="nv">Odd</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Parity_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">None</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">Even</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">Odd</span>  <span class="p">=&gt;</span> <span class="mi">2</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Control Register for a hypothetical UART device.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">UART_Control_Register_T</span> <span class="kr">is</span>
      <span class="kr">record</span>
         <span class="n">Baud_Rate</span> <span class="p">:</span> <span class="n">Baud_Rate_T</span><span class="p">;</span>
         <span class="n">Parity</span>    <span class="p">:</span> <span class="n">Parity_T</span><span class="p">;</span>
         <span class="n">Unused</span>    <span class="p">:</span> <span class="kt">Boolean</span> <span class="p">:=</span> <span class="kc">False</span><span class="p">;</span>
         <span class="n">ISR</span>       <span class="p">:</span> <span class="kt">Boolean</span><span class="p">;</span>
      <span class="kr">end record</span>
   <span class="kr">with</span> <span class="n">Volatile_Full_Access</span><span class="p">,</span>
     <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">8</span><span class="p">;</span>
   <span class="kr">for</span> <span class="n">UART_Control_Register_T</span> <span class="kn">use</span>
      <span class="nn">record</span>
         <span class="n">Baud_Rate</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">2</span><span class="p">;</span>
         <span class="n">Parity</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">3</span> <span class="p">..</span> <span class="mi">4</span><span class="p">;</span>
         <span class="n">Unused</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">5</span> <span class="p">..</span> <span class="mi">6</span><span class="p">;</span>
         <span class="n">ISR</span>       <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">7</span> <span class="p">..</span> <span class="mi">7</span><span class="p">;</span>
      <span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The address of the UART control register.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="no">UART_CONTROL_REG_ADDR</span> <span class="p">:</span> <span class="kr">constant</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span>
     <span class="p">:=</span> <span class="n">To_Address</span><span class="p">(</span><span class="mi">16</span><span class="err">#</span><span class="mi">8000_0040</span><span class="err">#</span><span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The UART control register itself.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="n">UART_Control_Register</span> <span class="p">:</span> <span class="n">UART_Control_Register_T</span>
   <span class="kn">with</span> <span class="nn">Import</span><span class="p">,</span>
     <span class="n">Convention</span> <span class="p">=&gt;</span> <span class="n">Ada</span><span class="p">,</span>
     <span class="kt">Address</span>    <span class="p">=&gt;</span> <span class="n">UART_CONTROL_REG_ADDR</span><span class="p">;</span>

<span class="kr">begin</span>
   <span class="c1">--  Configure the UART.</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Baud_Rate</span> <span class="p">:=</span> <span class="n">b_115200</span><span class="p">;</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Parity</span>    <span class="p">:=</span> <span class="n">Even</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Main</span><span class="p">;</span>
</pre>
</div>

<p>
	Contrast this with the same functionality implemented in C. 
	Despite being shorter in length, the register cannot be altered without using bitwise operators to manipulate the individual fields.
	This approach is generally considered more error-prone than using a record in Ada overlaid at the register's memory-mapped address.
	It is possible to define a struct type in C with bit-fields for the individual elements, 
	however the C standard does not guarantee the layout and order of the individual fields<sup><a href="#footnote_5" id="footnote_5_link">5</a></sup>.
</p>

<div class="code-block">
	<pre><span/><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"/>

<span class="cp">#define UART_CNTL_REG_ADDR       0x80000040</span>
<span class="cp">#define UART_CNTL_BAUD_MASK      0x07</span>
<span class="cp">#define UART_CNTL_BAUD_SHIFT     0</span>
<span class="cp">#define UART_CNTL_PARITY_MASK    0x18</span>
<span class="cp">#define UART_CNTL_PARITY_SHIFT   3</span>
<span class="cp">#define UART_CNTL_IE_MASK        0x80</span>
<span class="cp">#define UART_CNTL_BAUD_9600      0</span>
<span class="cp">#define UART_CNTL_BAUD_14400     1</span>
<span class="cp">#define UART_CNTL_BAUD_115200    7</span>
<span class="cp">#define UART_CNTL_PARITY_NONE    0</span>
<span class="cp">#define UART_CNTL_PARITY_EVEN    1</span>
<span class="cp">#define UART_CNTL_PARITY_ODD     2</span>
<span class="cp">#define UART_CNTL_ISR_ENABLE     2</span>
<span class="cp">#define UART_CNTL_ISR_DISABLE    2</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/** The UART control register pointer. */</span>
	<span class="kt">volatile uint8_t</span> <span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">UART_CNTL_REG_ADDR</span><span class="p">;</span>

	<span class="c1">// Configure the UART.</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_CNTL_BAUD_MASK</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">|=</span> <span class="n">UART_CNTL_BAUD_115200</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_CNTL_PARITY_MASK</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_CNTL_PARITY_EVEN</span> <span class="o">&lt;&lt;</span> <span class="n">UART_CNTL_PARITY_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</div>
<p>
	For anyone interested in learning more about Ada, or tutorials for learning the language, I recommend they visit
	AdaCore's learning center, at <a href="https://learn.adacore.com/">learn.adacore.com</a>, and 
	Olivier Henley's fantastic list of Ada resources at <a href="https://github.com/ohenley/awesome-ada">Awesome Ada</a>.
</p>


<h2 id="the_bad">The Bad and the Ugly <a class="permalink" href="#the_bad">#</a></h2>
<p>
	No programming language is perfect, and Ada is no exception.
	I preface this section by freely admitting that I am by no means an expert in the Ada programming language.
	Some of these (minor) complaints could be perfectly explained by my naivet&#233; of established conventions and inexperience with the language.
</p>
<p>
	<b>Poor pointer semantics</b> - The requirement to declare a pointer-to-type as a new type feels especially onerous.
	However contextually intuitive the act of declaring a distinct pointer type may be to the compiler, 
	it provides an unnecessary burden to the programmer. 
	Conversion to and from &#8212;and subsequent dereferencing of&#8212; pointers is unnecessarily cumbersome. 
	Needing to instantiate the generic library 
	<a href="https://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-7-2.html" target="_blank"><code>Address_To_Access_Conversions</code></a> 
	to do something as simple as creating a pointer from an arbitrary address seems like unnecessary overkill.
	All this being said, I like the semantic intuitiveness of Ada's <i>access types</i>, in contrast to C's pointers.
	The noted absence of pointer arithmetic is very welcome: <i>Access types</i> in Ada are not a numeric type in any form.
	They point to a memory address, and allow <i>access</i> to the value located there. Simple, sensible. 
	Perhaps these minor inconveniences are simply unavoidable consequences of integrating a low-level concept like pointers into higher-level language constructs. 
	For reasons like this, Ada is hard to place on this continuum. 
	Despite the presence of many higher-level constructs such as ranges, fat-pointers and object-orientation, 
	Ada is a language principally oriented around low-level concerns, which is a perfect segue into my second issue...
</p>
<p>
	<b>The runtime</b> - In addition to implementing Ada's standard library, 
	it's responsible for a variety of runtime functions, such as performing range checks on constained types.
	Comprehensive knowledge of the Ada runtime and its structure is required for the implementation of even moderately high-level language constructs on a particular platform.
	I will admit being unaccustomed to being concerned with a language's runtime library when targeting bare-metal. 
	I found the process of implementing my own runtime library for a bare-metal target to be particularly unintuitive. 
	When beginning the <a href="https://github.com/ajxs/cxos" target="_blank">CXOS</a> project, 
	my compiler did not ship with a suitable <i>zero-footprint</i> runtime library for the x86 platform. 
	As a result I was forced to learn the process of implementing a bare-metal x86 runtime for myself. 
	The equivalent process of putting together the build pipeline and infrastructure for a bare-metal C environment is much more straightforward.
	The ability to make highly granular modifications to the language's runtime is extremely useful for deployments on platforms with limited resources or functionality, 
	however the complicated nature of this process serves as a barrier to uptake that other language's may not have. 
	This is by no means an insurmountable problem, albeit one that I found particularly confusing for a newcomer.
</p>
<p>
	I put together a comprehensive guide to setting up an Ada runtime library suitable for operating system development on the x86 platform, 
	which can be viewed <a href="https://wiki.osdev.org/Ada_Runtime_Library" target="_blank">here</a>.
</p>
<p>
	Despite my minor misgivings, my experiences with Ada remain positive overall. 
	More than once I've heard online detractors accuse Ada of having aged poorly, 
	or excuse it on the basis that it was a product of its age; 
	A historical artefact to be taken as-is, not to be judged by today's &#8212;impliedly higher&#8212; standards. 
	I contend the fact that a modern developer can recognise in Ada many of the high-level constructs considered unique to modern scripting languages demonstrates it is in fact the programming ecosystem on the whole that's aged poorly. 
	I also wonder if complicated low-level programming concepts would be more intuitive to beginners if taught through Ada instead of C, 
	as is common in computer science and engineering faculties worldwide.
</p>

<h2 id="what_happened">What Happened? <a class="permalink" href="#what_happened">#</a></h2>
<p>
	Despite the many great things it has to offer, Ada has never gained much ground as a mainstream programming language outside of the aerospace, and the defense industries.
	Many explanations have been offered as to why, with language historians often citing Ada's early compiler ecosystem as a barrier for the language's wider adoption.
	Veterans of the DoD's Ada mandate trade 
	<a href="http://www.somethinkodd.com/oddthinking/category/geek/software-development/rat1000/">war stories</a>
	about long compilation times on expensive, proprietary development infrastructure.
	The technical challenge of implementing, and operating an Ada compiler on contemporary hardware was so significant that enterprise software tool developer Rational would even go so far as creating a dedicated workstation for the task, 
	the <a href="https://en.wikipedia.org/wiki/Rational_R1000">Rational R1000</a><sup><a href="#footnote_6" id="footnote_6_link">6</a></sup>.
	Even with the Ada standard being publicly available,
	It wouldn't be until the release of <i>GNAT</i> in 1995 &#8212;based on the FSF's GCC compiler&#8212; that Ada would have a freely available compiler.
</p>
<p>
	Despite Department of Defense sponsored studies acknowledging Ada as the most suitable language for the task (National Research Council, 1997),
	the DoD would ultimately 
	<a href="https://www.adahome.com/articles/1997-04/po_memopaige.html">repeal</a>
	its controversial mandate<sup><a href="#footnote_7" id="footnote_7_link">7</a></sup> that all in-house mission-critical software be developed in Ada.
	By this point in time the DoD had largely shifted its focus away from sponsoring expensive in-house software development, 
	and towards the utilisation of 
	<a href="https://en.wikipedia.org/wiki/Commercial_off-the-shelf"><i>COTS</i></a> (Commercial Off The Shelf) software.
	This event would mark the beginning of Ada's decline in the general programming community.
</p>
<p>
	For the development of the benighted F-35 Joint Strike Fighter's avionics software, 
	Lockheed Martin would ultimately choose to forgo Ada in lieu a heavily abridged dialect of C++<sup><a href="#footnote_8" id="footnote_8_link">8</a></sup>.
	John H. Robb, the Senior Manager of the F-35 Joint Strike Fighter Air Vehicle Software team at Lockheed Martin Aeronautics Fort Worth 
	<a href="https://web.archive.org/web/20111219004314/http://journal.thedacs.com:80/issue/53/158" target="_blank">writes on the subject</a>:
	<i>"Ada was seen as the technically superior and more robust language, 
	but concern over the ability to successfully staff the software engineers required to develop the massive amounts of 
	safety critical software caused the F-35 team to carefully look and finally to choose C and C++ for the implementation of safety critical software."</i> 
	For Ada fans this statement is bittersweet indeed.
</p>

<h2 id="whats_next">What's Next, and What Have We Learned? <a class="permalink" href="#whats_next">#</a></h2>

<p>
	For all the water-cooler chatter of obsolescence, Ada still enjoys serious respect in industries where failure is not an option. 
	Nvidia <a href="https://www.adacore.com/company/partners/nvidia">recently</a> chose Ada and its SPARK subset<sup><a href="#footnote_9" id="footnote_9_link">9</a></sup> 
	as their language of choice for development of safety-critical firmware in their embedded-systems.
	Some other notable users of Ada include the European Space Agency<sup><a href="#footnote_10" id="footnote_10_link">10</a></sup>, 
	BAE Systems, Saab, Thales, and <a href="http://archive.adaic.com/projects/atwork/boeing.html">Boeing</a>.
	A quick glance at leading Ada compiler manufacturer AdaCore's 
	<a href="https://www.adacore.com/company/our-customers" target="_blank">customer list</a> 
	demonstrates that the market for Ada is certainly alive and well.
	The historical record will likely prove kinder to Ada than its critics.
</p>
<p>
	Many developers point to Rust as the systems programming language of the future. 
	Rust is a language that markets itself on its focus on <i>safety</i><sup><a href="#footnote_11" id="footnote_11_link">11</a></sup>, 
	which invites comparisons against both C and Ada (for vastly different reasons). 
	Superficial comparisons aside, 
	Rust seems like a language that has neither learned much from C's failures, nor from Ada's successes. 
	Despite what the Rust community may say &#8212;or the algal bloom of new OSdev projects in Rust&#8212; 
	Rust does not seem well adapted to low-level programming:
	It lacks basic features necessary for the task, like bitfields, and data structure packing. 
	Its foreign function interface seems particularly poorly implemented. 
	The <a href="https://doc.rust-lang.org/nomicon/ffi.html">official Rust documentation</a> 
	suggests the use of the external third-party <code>libc</code> library (called a <i>'crate'</i> in Rust parlance)
	to provide the type definitions necessary to interface with C programs. 
	As of the time of writing, this crate has had 
	<a href="https://crates.io/crates/libc/versions" target="_blank">95 releases</a><sup><a href="#footnote_12" id="footnote_12_link">12</a></sup>.
	Contrast this with Ada's <code>Interfaces.C</code> package, 
	which was added the language in Ada 95 and hasn't needed to change in any fundamental way since.
	Despite Rust's present shortcomings, 
	it could prove to be a capable language that has much to offer if it can manage to standardise itself and evolve in a sensible way<sup><a href="#footnote_13" id="footnote_13_link">13</a></sup>.
</p>

<p>
	I am nothing if not an idealist, for better or worse.
	I have been willing to pick for myself the smallest hills to die on in matters of technical dispute. 
	When push comes to shove however, it pays to be pragmatic.
	It is true of course that any fully-featured systems programming language can be utilised in a safety-critical manner. 
	As John H. Robb himself so eloquently notes in the aforementioned article: 
	<i>"...the basic elements required to make a language work in [the safety-critical] domain are persistence, 
	determination, and good software engineering discipline"</i>. 
	This is of course true, however the qualities he mentions are valuable commodities indeed.
	If persistence, determination, and discipline are to be requirements, 
	then why not choose a language that requires less of such rigor in order to achieve the same high-quality results?
	After all, software is certainly easier to <a href="https://en.wikipedia.org/wiki/Morris_worm" target="_blank">get</a>
	<a href="https://nvd.nist.gov/vuln/detail/CVE-2019-3568" target="_blank">wrong</a> than it is to get right.
</p>

<hr/>
<h2 id="references">References <a class="permalink" href="#references">#</a></h2>
<ul id="references-list">
	<li>
		William A. Whitaker (1993). Ada - The Project, The DoD High Order Language Working Group. 
		<i>ACM SIGPLAN Notices</i> Vol. 28, No. 3, March 1993.
	</li>
	<li>
		National Research Council (1997). 
		Ada and Beyond: Software Policies for the Department of Defense. 
		Washington, DC: The National Academies Press. 
		https://doi.org/10.17226/5463.
	</li>
	
</ul>

<hr/>
<ol class="footnotes">
	<li id="footnote_1">
		In comparison to the plethora of modern languages that count C as an ancestor.
	<a href="#footnote_1_link">&#8626;</a></li><li id="footnote_2">
		It is worth noting that in the days of Ada's conception the United States military,
		or at very least their government, 
		could have very well been the chief developer and consumer of high-assurance embedded systems worldwide.
		If there was to be any paradigm shift in the developmental methodology of such systems,
		it would seem likely that it would have come from this sector.
	<a href="#footnote_2_link">&#8626;</a></li><li id="footnote_3">
		&#224; la Javascript.
	<a href="#footnote_3_link">&#8626;</a></li><li id="footnote_4">
		The oft-repeated claim that embedded development within the DoD was plagued by a troublesome and mountainous
		plurality
		of different languages has been anecdotally disputed online, usually by Ada's detractors. Even if this were not
		true, I
		find it hard to believe that JOVIAL would be a more ideal standardised language for future projects.
	<a href="#footnote_4_link">&#8626;</a></li><li id="footnote_5">
		Refer to section 6.7.2.1 paragraph 11 of the C1X standard.
	<a href="#footnote_5_link">&#8626;</a></li><li id="footnote_6">
		The Rational R1000 workstation is an interesting topic in its own right.
		The Danish Data Museum has detailed their excellent work
		<a href="https://datamuseum.dk/wiki/Rational/R1000s400">restoring</a>
		an R1000/s400 computer donated to them by a Danish aerospace manufacturer.
	<a href="#footnote_6_link">&#8626;</a></li><li id="footnote_7">
		While the mandate itself was never popular with developers, 
		the repealing of the mandate was probably as much a cost-saving exercise as anything.
		Without a specific requirement to use the Ada programming language,
		DoD projects would likely be open to more competitive bidding from a wider range of software vendors.
		It's also worth noting that historical accounts attest to the teams commonly receiving 'waivers' for the mandate.
		Enforcement of the mandate seems to have been fairly soft in its later days.
	<a href="#footnote_7_link">&#8626;</a></li><li id="footnote_8">
		The Joint Strike Fighter Air Vehicle (AV) C++ Rules were developed by Lockheed Martin to create a dialect of C++
		compatible with safety-critical software engineering. Bjarne Stroustrup hosts a copy of the guidelines on his
		website: <a href="https://www.stroustrup.com/JSF-AV-rules.pdf">https://www.stroustrup.com/JSF-AV-rules.pdf</a>.
	<a href="#footnote_8_link">&#8626;</a></li><li id="footnote_9">
		<a href="https://en.wikipedia.org/wiki/SPARK_(programming_language)">SPARK</a> is a formally-provable subset of Ada.
		SPARK reduces the scope of the language to a strict subset for which formal verification of lack of runtime errors is possible.
	<a href="#footnote_9_link">&#8626;</a></li><li id="footnote_10">
		Whenever the topic of Ada arises on Hacker News, 
		there's inevitably someone smugly bringing up the failure of the first test flight of the European Space Agency's <i>Ariane V</i> 
		rocket as though it were some searing indictment of the Ada programming language.
		Without delving unnecessarily far into a subject about which a 
		<a href="https://www.bugsnag.com/blog/bug-day-ariane-5-disaster">wealth</a>
		<a href="https://www.dropbox.com/s/tr02fmo4xzytzhv/Bashar-Ariane5.pdf?dl=0">of</a>
		<a href="http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html">material</a> 
		has already been written, it is suffice say that Ada can be spared the blame for this accident.
		Evidence supports the crash having been caused by <em>poor design practices</em>, the end.
		Despite the wealth of evidence exonerating the language,
		<a href="https://news.ycombinator.com/item?id=20935953">some people</a> will simply never get it, 
		and conjecture persists in the face of common sense.
	<a href="#footnote_10_link">&#8626;</a></li><li id="footnote_11">
		<i>Safety</i> is a different concept than being suitable for <i>safety-critical</i> applications.
		Rust is designed principally around the elimination of the kind of memory bugs associated with the C programming language, 
		such as <i>use after free</i>, <i>buffer overflow</i> and <i>memory leaking</i>,
		among others.
	<a href="#footnote_11_link">&#8626;</a></li><li id="footnote_12">
		This begs the question: <i>what about an C interface requires this much work?</i> 
		Admittedly the <code>libc</code> crate ostensibly provides a very broad scope of functionality.
		Their <a href="https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md">official RFC</a> states the opposite: 
		<i>"The primary purpose of this crate is to provide all of the definitions necessary to easily interoperate with C 
		code (or "C-like" code) on each of the platforms that Rust supports."</i>, 
		indicating a narrow scope of requirements.
		However browsing the <a href="https://github.com/rust-lang/libc/issues">Issues</a> 
		section their Github gives the opposite impression. 
		Either way, interoperability (in my experience) remains dysfunctional at best.
	<a href="#footnote_12_link">&#8626;</a></li><li id="footnote_13">
		Rust, which as of the time of writing has yet to be formally standardised, 
		seems to have a very wide variety of hands on the wheel.
		It enjoys an active and enthusiastic community,
		which ostensibly appears to be a collection of refugees from the Node.js and Golang communities. 
		Despite my misgivings about some of Rust's design decisions, I can see its benefits. 
		For companies such as Mozilla, migrating their products from C++ to Rust seems like a great idea.
	<a href="#footnote_13_link">&#8626;</a></li></ol>
	</div>
</article>

		<footer>
			Â© 2024 AJXS
		</footer>
	</body>
</html>
