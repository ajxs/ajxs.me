<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="author" content="ajxs">
		<meta name="description" content="An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.">
		<meta name="robots" content="index, follow">
		<meta name="keywords" content="ajxs,synthesisers,programming,Programming">
		<meta name="reply-to" content="ajxs@panoptic.online">
		<meta name="owner" content="ajxs">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" type="text/css" href="/static/style.css">
		<link rel="stylesheet" type="text/css" href="/static/code.css">
		<link rel="alternate" type="application/rss+xml" title="Blog Posts" href="/site.rss">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">

		<title>~ajxs/Giving Ada a Chance</title>
	</head>
	<body>
		<header>
			<a href="/">~ajxs</a>
		</header>
		<article class="blog-entry">
	<header>
		<h1>Giving Ada a Chance</h1>
		<div class="date">2021.01.13</div>
		<div class="description">An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.</div>
				<div class="tags">
					<span>Tagged as: </span>
					<ul class="tag-list">
							<li><a href="/blog/tag/Programming.html">Programming</a></li>
					</ul>
				</div>
	</header>
	<div class="entry-body">
			<div class="note">
		<span class="heading">TL;DR:</span>
		Ada is an interesting and robust programming language that has a lot to offer modern developers of system and bare-metal software. 
		At very least, Ada presents many interesting ideas that designers of modern programming languages could stand to learn much from. 
		If you want a 30-second version of this article, 
		check out the <a href="#practical_example" target="_blank">practical example</a> that I provide for a comparison of Ada with C.
	</div>
	
	<div class="note">
		<span class="heading">Update October 2022:</span>
		After receiving some fantastic correspondence from experienced Ada developers,
		I've made some amendments to this article to correct some factual errors, remove some unsubstantiated conjecture,
		and improve the general quality of the writing.
	</div>
	
	<p>
		Much of the technical material presented in this article is available as part of
		<a href="https://wiki.osdev.org/User:Ajxs" target="_blank">my contributions</a> to 
		<a href="https://wiki.osdev.org/Main_Page" target="_blank">osdev.org</a>
	</p>
	
	<h2 id="a_chance_collision">A Chance Collision <a class="permalink" href="#a_chance_collision">#</a></h2>
	<p>
		By no deliberate design of my own, I happen to live close to a university. 
		Not in the kind of 'University town' common to much of Europe or the United States, 
		but in the densely packed suburban sprawl of Sydney's inner-city. 
		Making my way home one serendipitous afternoon, 
		I happened across a sizeable stack of books sitting on the curb outside the aforementioned University's engineering buildings. 
		The university was in the process of liquidating its stockpile of old engineering books, 
		and had left them in a pile for the local council to collect. 
		Sifting through the pile for anything interesting, 
		two books in caught my eye: <i>Building Parallel, Embedded, and Real-Time Applications with Ada</i>, 
		and <i>Concurrent and Real-Time Programming in Ada</i>.
	</p>
	<p>
		I'd heard of Ada before.
		I understood that it came from a pedigree of languages developed for the United States military, 
		and that it still occupied a niche in the development of safety-critical applications,
		but that was about all I knew.
		Curious, I threw the books in my bag and off I went.
	</p>
	
	<h2 id="exceeding_my_expectations">Exceeding My Expectations <a class="permalink" href="#exceeding_my_expectations">#</a></h2>
	<p>
		Admittedly, I had pictured Ada's syntax resembling the uncompromising verbosity and rigid construction of COBOL, 
		or perhaps the Lovecraftian hieroglyphics of APL's various eldritch incarnations. 
		Turning the pages, 
		I was pleasantly surprised to see modern constructs associated with modern high-level languages such as ranges, 
		slicing, and exception-handling.
		The syntax &#8212;admittedly verbose by modern standards<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>&#8212; 
		seemed carefully constructed to make the language comprehensible at a glance.
	</p>
	<p>
		The fact that Ada was designed with embedded software in mind had me interested. 
		I already had some limited experience with bare-metal development on the x86 and ARM platforms using C and assembly, 
		so the prospect of using higher-level constructs on bare-metal had me intrigued.
	</p>
	
	<h2 id="not_the_camel_you_expected">Not the Camel You Expected <a class="permalink" href="#not_the_camel_you_expected">#</a></h2>
	<p>
		A common criticism of Ada is that it's a language 'designed by committee',
		or even worse, a language 'designed by committee <em>for the military</em>'<sup><a href="#footnote_2" id="footnote_2_link">2</a></sup>. 
		The implication being that this would preclude it from having any kind of <em>real-world</em> practicality<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>. 
		I'll spare readers a detailed retelling of Ada's conception within the Department of Defense's 
		<a href="http://archive.adaic.com/pol-hist/history/holwg-93/holwg-93.htm" target="_blank">'High Order Language Working Group'</a> (HOLWG), 
		save to say that Ada was born of the need for single, 
		unified higher-level language suitable for use in the multitude of real-time embedded systems developed by the DoD<sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>. 
		In the wise words of the working-group's chair, Colonel William A. Whitaker: 
		<i>'It was concluded that no existing language could be adopted as a single common high order language for the DoD, 
		but that a single language meeting essentially all the requirements was both feasible and desirable'</i>. 
		If such a thing was indeed feasible, the DoD's deep pockets would help it bring it into existence. 

		Bell Labs were invited to evaluate the C programming language against the DoD requirements,
		however (In the words of the HOLWG)
		<i>'...they said that there was no chance of C meeting the requirements of readability, safety, etc.'</i> (Whitaker, 1993). 
	</p>
	<p>
		In what would prove a controversial decision, 
		the DoD would go so far as to mandate the use of Ada for <em>all</em> in-house software engineering.
	</p>

	<h2 id="what_makes_it_so_good">So What Makes It Special? <a class="permalink" href="#what_makes_it_so_good">#</a></h2>
	<p>
		Ada has many useful features that are of particular interest for low-level programming.
		I'll go over a few of my favourite features below.
	</p>

	<h3>Custom Types</h3>
	<p>
		In addition to being a strongly typed language, 
		Ada allows for the definition of new scalar, enumerated, and record types (the equivalent of structures in C).
		Custom primitive types can also be constrained to a predefined range of values.
	</p>
	<p>
		The example below demonstrates the definition of a new integer type based upon Ada's native <code>Natural</code> type,
		restricted to a predefined range.
		The use of the subtype directive informs the compiler that other variables of the <code>Natural</code> type are compatible with the newly defined subtype.
	</p>

	<div class="code-block"><pre><span></span><span class="no">VGA_COL_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">80</span><span class="p">;</span>
<span class="no">VGA_ROW_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">24</span><span class="p">;</span>

<span class="kd">subtype</span> <span class="kt">Col</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_COL_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">Row</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_ROW_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>

	<p>
		The below example illustrates the creation of incompatible custom integer types. 
		While their base type and range constraints are identical, Ada treats both as separate, incompatible types. 
		An assignment of a variable of one type to the value of another is illegal, and will trigger a compile-time error.
	</p>

	<div class="code-block"><pre><span></span><span class="kd">type</span> <span class="kt">Integer_1</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Integer_2</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">A</span> <span class="p">:</span> <span class="n">Integer_1</span> <span class="p">:=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">B</span> <span class="p">:</span> <span class="n">Integer_2</span> <span class="p">:=</span> <span class="n">A</span><span class="p">;</span> <span class="c1">-- illegal!</span>
</pre></div>

	<p>
		The following example demonstrates the creation of a custom enumerated type. 
		It also demonstrates a subtype of an enumerated type with a constrained range of values.
	</p>

	<div class="code-block"><pre><span></span><span class="kd">type</span> <span class="kt">Day_Of_Week</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Monday</span><span class="p">,</span> <span class="nv">Tuesday</span><span class="p">,</span>
  <span class="nv">Wednesday</span><span class="p">,</span> <span class="nv">Thursday</span><span class="p">,</span> <span class="nv">Friday</span><span class="p">,</span> <span class="nv">Saturday</span><span class="p">,</span> <span class="nv">Sunday</span><span class="p">);</span>

<span class="kd">subtype</span> <span class="kt">Work_Day</span> <span class="kr">is</span> <span class="n">Day_Of_Week</span> <span class="kr">range</span> <span class="n">Monday</span> <span class="p">..</span> <span class="n">Friday</span><span class="p">;</span>
</pre></div>

	<p>
		A variable with the type of <code>Work_Day</code> is restricted to its constrained range. 
		Any attempt to assign a value outside this range to a variable of this type will raise a <code>Constraint_Error</code> exception at runtime.
	</p>

	<h3>Representation Clauses</h3>
	<p>
		One feature that particularly impressed me is Ada's <i>representation clauses</i>. 
		They provide a construct for defining the in-memory representation of a type. 
		I could immediately see how I could use this feature in my own long-suffering operating system projects.
	</p>
	<p>
		The following example demonstrates the definition of a record type, 
		as well as its associated representation in memory.
	</p>
	
	<div class="code-block"><pre><span></span><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The format of the System Table Descriptor pointer used by the processor</span>
<span class="c1">--  to load descriptor tables like the GDT and IDT.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">System_Table_Descriptor</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">Size</span>   <span class="p">:</span> <span class="n">Unsigned_16</span><span class="p">;</span>
   <span class="n">Offset</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span><span class="p">;</span>
<span class="kr">end record</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">48</span><span class="p">;</span>

<span class="kr">for</span> <span class="n">System_Table_Descriptor</span> <span class="kn">use</span> <span class="n">record</span>
  <span class="n">Size</span>   <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span>  <span class="p">..</span> <span class="mi">15</span><span class="p">;</span>
  <span class="n">Offset</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">16</span> <span class="p">..</span> <span class="mi">47</span><span class="p">;</span>
<span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>
</pre></div>

	<p>
		The <code>Size</code> aspect specifier instructs the compiler that the <code>System_Table_Descriptor</code> type must be 48 bits in size. 
		The record representation clause instructs the compiler as to the required layout of this record type in memory. 
		This example specifies that the <code>Size</code> member should occupy bits 0 to 15, 
		and the <code>Offset</code> member should occupy bits 16 to 47. 
		This feature is analogous to C's bit-fields. 
	</p>
	<p>
		The following example demonstrates defining the in-memory representation of an enumerated type.
	</p>
	
	<div class="code-block"><pre><span></span><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The privilege level for a particular descriptor.</span>
<span class="c1">--  These correspond to the 'protection ring' that this descriptor is</span>
<span class="c1">--  accessible from.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">Descriptor_Privilege_Level</span> <span class="kr">is</span> <span class="p">(</span>
   <span class="nv">Ring_0</span><span class="p">,</span>
   <span class="nv">Ring_1</span><span class="p">,</span>
   <span class="nv">Ring_2</span><span class="p">,</span>
   <span class="nv">Ring_3</span>
<span class="p">)</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">Descriptor_Privilege_Level</span> <span class="kn">use</span> <span class="p">(</span>
   <span class="n">Ring_0</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">Ring_1</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Ring_2</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Ring_3</span> <span class="p">=&gt;</span> <span class="mi">3</span>
<span class="p">);</span>
</pre></div>

	<p>
		The <code>Size</code> aspect specifier instructs the compiler that the <code>Descriptor_Privilege_Level</code> type must be 2 bits in size.
		The representation clause instructs the compiler as to required representation of each possible value of the enumerated type in memory. 
		In this example the value of <code>Ring_0</code> will be represented by a value of <code>0x0</code> in memory,
		the value of <code>Ring_1</code> will be represented by <code>0x1</code>, and so on.
	</p>
	
	<h2 id="practical_example">A Practical Example <a class="permalink" href="#practical_example">#</a></h2>
	<p>
		The following example, and accompanying comparison with C, demonstrates the configuration of a hypothetical UART device by interfacing with an 8-bit memory-mapped configuration register.
		This example has been adapted from a presentation by AdaCore viewable <a href="https://www.youtube.com/watch?v=qvmDqbuQe-M" target="_blank">here</a>.
	</p>
	
	<div class="code-block"><pre><span></span><span class="kn">with</span> <span class="n">System.Storage_Elements</span><span class="p">;</span> <span class="kn">use</span> <span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="c1">-------------------------------------------------------------------------------</span>
<span class="c1">--  Main</span>
<span class="c1">-------------------------------------------------------------------------------</span>
<span class="kd">procedure</span> <span class="nf">Main</span> <span class="kr">is</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Baud rate type.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Baud_Rate_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">b_9600</span><span class="p">,</span> <span class="nv">b_14400</span><span class="p">,</span> <span class="nv">b_115200</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Baud_Rate_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">b_9600</span>   <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">b_14400</span>  <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">b_115200</span> <span class="p">=&gt;</span> <span class="mi">7</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Parity Select Type</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Parity_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">None</span><span class="p">,</span> <span class="nv">Even</span><span class="p">,</span> <span class="nv">Odd</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Parity_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">None</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">Even</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">Odd</span>  <span class="p">=&gt;</span> <span class="mi">2</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Control Register for a hypothetical UART device.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">UART_Control_Register_T</span> <span class="kr">is</span> <span class="kr">record</span>
      <span class="n">Baud_Rate</span> <span class="p">:</span> <span class="n">Baud_Rate_T</span><span class="p">;</span>
      <span class="n">Parity</span>    <span class="p">:</span> <span class="n">Parity_T</span><span class="p">;</span>
      <span class="n">Unused</span>    <span class="p">:</span> <span class="kt">Boolean</span> <span class="p">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="n">ISR</span>       <span class="p">:</span> <span class="kt">Boolean</span><span class="p">;</span>
   <span class="kr">end record</span> <span class="kr">with</span>
     <span class="n">Volatile_Full_Access</span><span class="p">,</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">8</span><span class="p">;</span>
   <span class="kr">for</span> <span class="n">UART_Control_Register_T</span> <span class="kn">use</span> <span class="n">record</span>
      <span class="n">Baud_Rate</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">2</span><span class="p">;</span>
      <span class="n">Parity</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">3</span> <span class="p">..</span> <span class="mi">4</span><span class="p">;</span>
      <span class="n">Unused</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">5</span> <span class="p">..</span> <span class="mi">6</span><span class="p">;</span>
      <span class="n">ISR</span>       <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">7</span> <span class="p">..</span> <span class="mi">7</span><span class="p">;</span>
   <span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The address of the UART control register.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="no">UART_CONTROL_REG_ADDR</span> <span class="p">:</span> <span class="kr">constant</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span> <span class="p">:=</span>
     <span class="n">To_Address</span> <span class="p">(</span><span class="mh">16#8000_0040#</span><span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The UART control register itself.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="n">UART_Control_Register</span> <span class="p">:</span> <span class="n">UART_Control_Register_T</span> <span class="kn">with</span>
     <span class="n">Import</span><span class="p">,</span>
     <span class="n">Convention</span> <span class="p">=&gt;</span> <span class="n">Ada</span><span class="p">,</span>
     <span class="kt">Address</span>    <span class="p">=&gt;</span> <span class="n">UART_CONTROL_REG_ADDR</span><span class="p">;</span>

<span class="kr">begin</span>
   <span class="c1">--  Configure the UART.</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Baud_Rate</span> <span class="p">:=</span> <span class="n">b_115200</span><span class="p">;</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Parity</span>    <span class="p">:=</span> <span class="n">Even</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Main</span><span class="p">;</span>
</pre></div>
	
	<p>
		Contrast this with the same functionality implemented in C. 
		Despite being shorter, the register cannot be altered without using bitwise operators to manipulate the individual fields.
		This approach is generally considered more error-prone than using a record in Ada overlaid at the register's memory-mapped address.
		It's possible to define a struct type in C with bit-fields for the individual elements, 
		however the C standard does not guarantee the layout and order of the individual fields<sup><a href="#footnote_5" id="footnote_5_link">5</a></sup>.
	</p>
	
	<div class="code-block"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>

<span class="cp">#define UART_CNTL_REG_ADDR       0x80000040</span>
<span class="cp">#define UART_CNTL_BAUD_MASK      0x07</span>
<span class="cp">#define UART_CNTL_BAUD_SHIFT     0</span>
<span class="cp">#define UART_CNTL_PARITY_MASK    0x18</span>
<span class="cp">#define UART_CNTL_PARITY_SHIFT   3</span>
<span class="cp">#define UART_CNTL_IE_MASK        0x80</span>
<span class="cp">#define UART_CNTL_BAUD_9600      0</span>
<span class="cp">#define UART_CNTL_BAUD_14400     1</span>
<span class="cp">#define UART_CNTL_BAUD_115200    7</span>
<span class="cp">#define UART_CNTL_PARITY_NONE    0</span>
<span class="cp">#define UART_CNTL_PARITY_EVEN    1</span>
<span class="cp">#define UART_CNTL_PARITY_ODD     2</span>
<span class="cp">#define UART_CNTL_ISR_ENABLE     2</span>
<span class="cp">#define UART_CNTL_ISR_DISABLE    2</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="cm">/** The UART control register pointer. */</span>
<span class="w">	</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">uart_control_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">UART_CNTL_REG_ADDR</span><span class="p">;</span>

<span class="w">	</span><span class="c1">// Configure the UART.</span>
<span class="w">	</span><span class="o">*</span><span class="n">uart_control_reg</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">UART_CNTL_BAUD_MASK</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="n">uart_control_reg</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">UART_CNTL_BAUD_115200</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="n">uart_control_reg</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">UART_CNTL_PARITY_MASK</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="n">uart_control_reg</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">UART_CNTL_PARITY_EVEN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">UART_CNTL_PARITY_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

	<p>
		For anyone interested in learning more about Ada, or tutorials for learning the language, I recommend they visit
		AdaCore's learning center, at <a href="https://learn.adacore.com/" target="_blank">learn.adacore.com</a>, and 
		Olivier Henley's fantastic list of Ada resources at <a href="https://github.com/ohenley/awesome-ada" target="_blank">Awesome Ada</a>.
	</p>
	
	
	<h2 id="the_bad">The Bad and the Ugly <a class="permalink" href="#the_bad">#</a></h2>
	<p>
		No programming language is perfect, and Ada is no exception.
		I freely admit that I'm by no means an expert in Ada,
		so some of these (minor) complaints might be explained by my naivet&#233; of established conventions and inexperience with the language.
	</p>
	<p>
		<b>Poor pointer semantics</b> - The requirement to declare a pointer-to-type as a new type feels especially onerous.
		Declaring a distinct pointer type may be intuitive to the compiler, 
		but it provides an unnecessary burden to the programmer. 
		Conversion to and from &#8212;and subsequent dereferencing of&#8212; pointers is unnecessarily cumbersome. 
		Needing to instantiate the generic library 
		<a href="https://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-7-2.html" target="_blank"><code>Address_To_Access_Conversions</code></a> 
		to do something as simple as creating a pointer from an arbitrary address seems like unnecessary overkill.
		That being said, I like the semantic intuitiveness of Ada's <i>access types</i>,
		they point to a memory address, and allow <i>access</i> to the value located there. 
		The noted absence of pointer arithmetic is very welcome: <i>Access types</i> in Ada are not a numeric type in any form.
	</p>
	<p>
		Perhaps these minor inconveniences are simply unavoidable consequences of integrating a low-level concept like pointers into higher-level language constructs. 
		Despite the presence of many higher-level constructs such as ranges, fat-pointers and object-orientation, 
		Ada is principally oriented around low-level concerns, which is a perfect segue into my second issue&#8230;
	</p>
	<p>
		<b>The runtime</b> - In addition to implementing Ada's standard library, 
		the runtime has a wide scope of responsibilities,
		such as performing range checks on constrained types.
		Comprehensive knowledge of the Ada runtime and its structure is required to implement even moderately high-level language constructs for a new platform.
	</p>
	<p>
		My compiler didn't ship with a suitable <i>zero-footprint</i> runtime library for the x86 platform. 
		As a result I had to implement my own 'zero-footprint' runtime library. 
		I found the process to be particularly unintuitive. 
		The equivalent process of putting together the build pipeline and infrastructure for a bare-metal C environment is much more straightforward.
		The ability to make highly granular modifications to the language's runtime is extremely useful if you're targeting platforms with limited resources or functionality.
		However the complicated nature of this process serves as a barrier to uptake that other languages may not have. 
		This is by no means an insurmountable problem, 
		just something I found particularly confusing as a newcomer.
	</p>
	<p>
		I put together a comprehensive guide to setting up an Ada runtime library suitable for operating system development on the x86 platform, 
		which can be viewed <a href="https://wiki.osdev.org/Ada_Runtime_Library" target="_blank">here</a>.
	</p>
	<p>
		Despite some minor misgivings, my experience with Ada remains positive overall. 
		More than once I've heard online detractors accuse Ada of having aged poorly, 
		or excuse it on the basis that it's a product of its time; 
		A historical artefact to be taken as-is, not to be judged by today's &#8212;presumably higher&#8212; standards.
		The fact that many of the high-level language constructs found in modern scripting languages have been in Ada since the beginning
		shows that maybe <em>the rest</em> of the programming ecosystem hasn't actually aged as well as we think.
	</p>
	
	<h2 id="what_happened">What Happened? <a class="permalink" href="#what_happened">#</a></h2>
	<p>
		Despite having a lot to offer, 
		Ada never gained much ground as a mainstream programming language outside the aerospace and defense industries.
		Many explanations have been offered as to why,
		with language historians often citing Ada's early compiler ecosystem as a barrier for the language's wider adoption.
		Veterans of the DoD's Ada mandate trade 
		<a href="http://www.somethinkodd.com/oddthinking/category/geek/software-development/rat1000/" target="_blank">war stories</a>
		about long compilation times on expensive, proprietary development infrastructure.
		The technical challenge of implementing, 
		and operating an Ada compiler on contemporary hardware was so significant that enterprise software tool developer Rational would even go so far as creating a dedicated workstation for the task, 
		the <a href="https://en.wikipedia.org/wiki/Rational_R1000" target="_blank">Rational R1000</a><sup><a href="#footnote_6" id="footnote_6_link">6</a></sup>.
		Even with the Ada standard being publicly available,
		It wouldn't be until the release of <i>GNAT</i> in 1995 &#8212;based on the FSF's GCC compiler&#8212; that Ada would have a freely available compiler.
	</p>
	<p>
		Despite Department of Defense sponsored studies acknowledging Ada as the most suitable language for the task (National Research Council, 1997),
		the DoD would ultimately 
		<a href="https://www.adahome.com/articles/1997-04/po_memopaige.html" target="_blank">repeal</a>
		its controversial mandate<sup><a href="#footnote_7" id="footnote_7_link">7</a></sup> that all in-house mission-critical software be developed in Ada.
		By this point in time the DoD had largely shifted its focus away from sponsoring expensive in-house software development, 
		and towards the utilisation of 
		<a href="https://en.wikipedia.org/wiki/Commercial_off-the-shelf" target="_blank"><i>COTS</i></a> (Commercial Off The Shelf) software.
		This event would mark the beginning of Ada's decline in the general programming community.
	</p>
	<p>
		For the development of the benighted F-35 Joint Strike Fighter's avionics software, 
		Lockheed Martin would ultimately choose to forgo Ada in lieu a heavily abridged dialect of C++<sup><a href="#footnote_8" id="footnote_8_link">8</a></sup>.
		John H. Robb, the Senior Manager of the F-35 Joint Strike Fighter Air Vehicle Software team at Lockheed Martin Aeronautics Fort Worth 
		<a href="https://web.archive.org/web/20111219004314/http://journal.thedacs.com:80/issue/53/158" target="_blank">writes on the subject</a>:
		<i>'Ada was seen as the technically superior and more robust language, 
		but concern over the ability to successfully staff the software engineers required to develop the massive amounts of 
		safety critical software caused the F-35 team to carefully look and finally to choose C and C++ for the implementation of safety critical software.'</i> 
		For Ada fans this statement is bittersweet indeed.
	</p>
	
	<h2 id="whats_next">What's Next, and What Have We Learned? <a class="permalink" href="#whats_next">#</a></h2>
	<p>
		For all the water-cooler chatter of obsolescence, Ada still enjoys serious respect in industries where failure isn't an option. 
		Nvidia <a href="https://www.adacore.com/company/partners/nvidia" target="_blank">recently</a> chose Ada and its SPARK subset<sup><a href="#footnote_9" id="footnote_9_link">9</a></sup> 
		as their language of choice for developing safety-critical firmware in their embedded-systems.
		Some other notable users of Ada include the European Space Agency<sup><a href="#footnote_10" id="footnote_10_link">10</a></sup>, 
		BAE Systems, Saab, Thales, and <a href="http://archive.adaic.com/projects/atwork/boeing.html" target="_blank">Boeing</a>.
		A quick glance at leading Ada compiler manufacturer AdaCore's 
		<a href="https://www.adacore.com/company/our-customers" target="_blank">customer list</a> 
		demonstrates that the market for Ada is certainly alive and well.
		The historical record will likely prove kinder to Ada than its critics.
	</p>
	<p>
		Many developers point to Rust as the systems programming language of the future. 
		Rust markets itself as a <i>safe</i><sup><a href="#footnote_11" id="footnote_11_link">11</a></sup> language, 
		which invites comparisons against both C and Ada (for vastly different reasons). 
		Superficial comparisons aside, 
		Rust seems like a language that has neither learned much from C's failures, nor from Ada's successes. 
		Despite what the Rust community may say &#8212;or the algal bloom of new OSdev projects in Rust&#8212; 
		Rust does not seem well adapted to low-level programming:
		It lacks basic features like bitfields, and data structure packing. 
		Its foreign function interface seems particularly poorly implemented. 
		The <a href="https://doc.rust-lang.org/nomicon/ffi.html" target="_blank">official Rust documentation</a> 
		suggests the use of the external third-party <code>libc</code> library (called a <i>'crate'</i> in Rust parlance)
		to provide the type definitions necessary to interface with C programs. 
		As of the time of writing, this crate has had 
		<a href="https://crates.io/crates/libc/versions" target="_blank">95 releases</a><sup><a href="#footnote_12" id="footnote_12_link">12</a></sup>.
		Contrast this with Ada's <code>Interfaces.C</code> package, 
		which was added the language in Ada 95 and hasn't needed to change in any fundamental way since.
		Despite Rust's present shortcomings, 
		it could prove to be a capable language that has much to offer if it can manage to standardise itself and evolve in a sensible way<sup><a href="#footnote_13" id="footnote_13_link">13</a></sup>.
	</p>
	
	<p>
		I'm nothing if not an idealist, for better or worse.
		I've been willing to pick for myself the smallest hills to die on in matters of technical dispute. 
		When push comes to shove however, it pays to be pragmatic.
		It's true of course that any fully-featured systems programming language can be utilised in a safety-critical manner. 
		As John H. Robb himself so eloquently notes in the aforementioned article: 
		<i>'&#8230;the basic elements required to make a language work in [the safety-critical] domain are persistence, 
		determination, and good software engineering discipline'</i>. 
		This is of course true, however the qualities he mentions are valuable commodities indeed.
		If persistence, determination, and discipline are to be requirements, 
		why not choose a language that requires less of them to achieve the same high-quality results?
		After all, software is certainly easier to <a href="https://en.wikipedia.org/wiki/Morris_worm" target="_blank">get</a>
		<a href="https://nvd.nist.gov/vuln/detail/CVE-2019-3568" target="_blank">wrong</a> than it is to get right.
	</p>
	
	<h2 id="references">References <a class="permalink" href="#references">#</a></h2>
	<ul id="references-list">
		<li>
			William A. Whitaker (1993). Ada - The Project, The DoD High Order Language Working Group. 
			<i>ACM SIGPLAN Notices</i> Vol. 28, No. 3, March 1993.
		</li>
		<li>
			National Research Council (1997). 
			Ada and Beyond: Software Policies for the Department of Defense. 
			Washington, DC: The National Academies Press. 
			https://doi.org/10.17226/5463.
		</li>
	</ul>
	
	<hr>
	<ol class="footnotes">
		<li id="footnote_1">
			In comparison to the plethora of modern languages that count C as an ancestor.
		<a href="#footnote_1_link">&#8626;</a></li><li id="footnote_2">
			It's worth noting that in the days of Ada's conception the United States military,
			or at very least the US government, 
			could very well have been the chief developer and consumer of high-assurance embedded systems worldwide.
			If there was to be any paradigm shift in the developmental methodology of such systems,
			it would seem likely that it would have come from this sector.
		<a href="#footnote_2_link">&#8626;</a></li><li id="footnote_3">
			In my humble opinion it's better to design a language to fit an existing problem domain than to pick your weapon of choice and set out in search of new problem domains to apply it to,
			&#224; la Javascript.
		<a href="#footnote_3_link">&#8626;</a></li><li id="footnote_4">
			The oft-repeated claim that embedded development within the DoD was plagued by a troublesome and mountainous plurality 
			of different languages has been anecdotally disputed online, usually by Ada's detractors. 
			Even if this weren't true,
			I find it hard to believe that JOVIAL would be a more ideal standard language for the DoD's future projects.
		<a href="#footnote_4_link">&#8626;</a></li><li id="footnote_5">
			Refer to section 6.7.2.1 paragraph 11 of the C1X standard.
		<a href="#footnote_5_link">&#8626;</a></li><li id="footnote_6">
			The Rational R1000 workstation is an interesting topic in its own right.
			The Danish Data Museum has detailed their excellent work
			<a href="https://datamuseum.dk/wiki/Rational/R1000s400" target="_blank">restoring</a>
			an R1000/s400 computer donated to them by a Danish aerospace manufacturer.
		<a href="#footnote_6_link">&#8626;</a></li><li id="footnote_7">
			While the mandate itself was never popular with developers, 
			the repealing of the mandate was probably as much a cost-saving exercise as anything.
			Without a specific requirement to use the Ada programming language,
			DoD projects would likely be open to more competitive bidding from a wider range of software vendors.
			It's also worth noting that historical accounts attest to the teams commonly receiving 'waivers' for the mandate.
			Enforcement of the mandate seems to have been fairly soft in its later days.
		<a href="#footnote_7_link">&#8626;</a></li><li id="footnote_8">
			The Joint Strike Fighter Air Vehicle (AV) C++ Rules were developed by Lockheed Martin to create a dialect of C++
			compatible with safety-critical software engineering.
			Bjarne Stroustrup hosts a copy of the guidelines on his website:
			<a href="https://www.stroustrup.com/JSF-AV-rules.pdf" target="_blank">https://www.stroustrup.com/JSF-AV-rules.pdf</a>.
		<a href="#footnote_8_link">&#8626;</a></li><li id="footnote_9">
			<a href="https://en.wikipedia.org/wiki/SPARK_(programming_language)" target="_blank">SPARK</a> is a formally-provable subset of Ada.
			SPARK reduces the scope of the language to a strict subset for which formal verification of lack of runtime errors is possible.
		<a href="#footnote_9_link">&#8626;</a></li><li id="footnote_10">
			Whenever the topic of Ada comes up on Hacker News, 
			someone inevitably brings up the failure of the European Space Agency's <i>Ariane V</i> rocket, 
			as though it were some searing indictment of the Ada programming language.
			Without delving unnecessarily far into a subject about which a 
			<a href="https://www.bugsnag.com/blog/bug-day-ariane-5-disaster" target="_blank">wealth</a>
			<a href="https://www.dropbox.com/s/tr02fmo4xzytzhv/Bashar-Ariane5.pdf?dl=0" target="_blank">of</a>
			<a href="http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html" target="_blank">material</a> 
			has already been written, it's suffice say that Ada can be spared the blame for this accident.
			Evidence supports the crash having been caused by <em>poor design practices</em>, the end.
			Despite the wealth of evidence exonerating the language,
			<a href="https://news.ycombinator.com/item?id=20935953" target="_blank">some people</a>
			will simply never get it, 
			and conjecture persists in the face of common sense.
		<a href="#footnote_10_link">&#8626;</a></li><li id="footnote_11">
			<i>Safety</i> is a different concept than being suitable for <i>safety-critical</i> applications.
			Rust is designed principally around the elimination of the kind of memory bugs associated with the C programming language, 
			such as <i>use after free</i>, <i>buffer overflow</i> and <i>memory leaking</i>,
			among others.
		<a href="#footnote_11_link">&#8626;</a></li><li id="footnote_12">
			This begs the question: <i>what about a C interface requires this much work?</i> 
			Admittedly the <code>libc</code> crate ostensibly provides a very broad scope of functionality.
			Their <a href="https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md" target="_blank">official RFC</a> 
			states the opposite: 
			<i>'The primary purpose of this crate is to provide all of the definitions necessary to easily interoperate with C 
			code (or "C-like" code) on each of the platforms that Rust supports.'</i>, 
			indicating a narrow scope of requirements.
			However browsing the <a href="https://github.com/rust-lang/libc/issues" target="_blank">Issues</a> 
			section their Github gives the opposite impression. 
			Either way, interoperability (in my experience) remains dysfunctional at best.
		<a href="#footnote_12_link">&#8626;</a></li><li id="footnote_13">
			Rust, which as of the time of writing has yet to be formally standardised, 
			seems to have a very wide variety of hands on the wheel.
			It enjoys an active and enthusiastic community,
			which ostensibly appears to be a collection of refugees from the Node.js and Golang communities. 
			Despite my misgivings about some of Rust's design decisions, I can see its benefits. 
			For companies such as Mozilla, migrating their products from C++ to Rust seems like a great idea.
		<a href="#footnote_13_link">&#8626;</a></li></ol>
	</div>
</article>

		<footer>
			<div class="links">
				<nav>
					<a href="/about.html">About Me</a>
					<a href="mailto:ajxs@panoptic.online" target="_blank">Email Me</a>
					<a href="https://github.com/ajxs" target="_blank">Github</a>
					<a href="/donate.html">Donate</a>
					<a href="/site.rss" target="_blank">RSS</a>
				</nav>
				Webring:
				<a href="https://webri.ng/webring/ajxs/previous?index=0">Previous</a> /
				<a href="https://webri.ng/webring/ajxs/random">Random</a> /
				<a href="https://webri.ng/webring/ajxs/next?index=0">Next</a>
			</div>

			Â© 2024 ajxs
		</footer>
	</body>

</html>
