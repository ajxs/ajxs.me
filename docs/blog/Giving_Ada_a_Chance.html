<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="author" content="ajxs">
		<meta name="description" content="An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.">
		<meta name="robots" content="index, follow">
		<meta name="keywords" content="Programming">
		<meta name="reply-to" content="ajxs@panoptic.online">
		<meta name="owner" content="ajxs">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>~ajxs/Giving Ada a Chance</title>
		<link rel="stylesheet" type="text/css" href="/static/style.css">
	</head>
	<body>
		<header>
			<a href="/">~ajxs</a>
		</header>
		<article class="blog-entry">
	<header>
		<h1>Giving Ada a Chance</h1>
		<div class="date">2021.01.13</div>
		<div class="short">An in-depth look at the Ada programming language, its history, and what it has to offer developers today. As well as a fistful of my humble opinions.</div>
		<div class="tags">
	<span>Tagged as: </span>
	<ul class="tag-list">
		<li><a href="/blog/tag/Programming.html">Programming</a></li>
	</ul>
</div>

	</header>
	<div class="entry-body">
		<div class="tldr colour_dark-bg"><span class="tldr-heading colour_light">TL;DR:</span> Ada is an extremely interesting and robust programming language that has a lot to offer modern developers of system 
	and bare-metal software. At very least, Ada presents many interesting ideas that designers of modern programming languages could stand to learn much from. If you want a 30 second version of this article, check out the 
	<a href="#practical_example">practical example</a> that I provide for a comparison of Ada with C.</div>

<p>
	Much of the technical material presented in this article is available as part of <a href="https://wiki.osdev.org/User:Ajxs">my contributions</a> to <a href="https://wiki.osdev.org/Main_Page">osdev.org</a>
</p>
<p>
	I consider myself a rational man. While I may believe in an entirely deterministic model of the universe, I certainly
	do not believe it to be guided by any conscious process.
	I do not believe in destiny. This absence of guidance makes such fortuitous occurrences as the one I will discuss all
	the more extraordinary, and for this I am all the more grateful.
</p>

<h2 id="a_chance_collision">A Chance Collision <a class="permalink" href="#a_chance_collision">#</a></h2>
<p>
	By no deliberate design of my own, I happen to live close to a university. Not in the kind of ‘University town’ common
	to much of Europe or the United States, but in the densely packed suburban sprawl of the inner-city. My regular walk
	to and from the local shopping centre takes me past several of the buildings belonging to the highly regarded
	engineering faculty of the aforementioned University.
</p>
<p>
	Making my way home one serendipitous afternoon, I happened across a sizeable stack of books sitting on the curb
	outside one of the University’s engineering buildings. The university was ostensibly in the process of liquidating its stockpile
	of old engineering books, and had left them in a pile for the local council to collect. Amongst material covering a
	wide variety of academic disciplines, two books in particular caught my eye: <i>Building Parallel, Embedded, and
	Real-Time Applications with Ada</i>, and <i>Concurrent and Real-Time Programming in Ada</i>.
</p>
<p>
	I had heard of Ada before. I understood that it came from a pedigree of languages developed for the United States
	military, and that it still occupied a niche in the development of safety-critical applications, nothing more.
	Curious, I threw the books in my bag and off I went.
</p>


<h2 id="exceeding my_expectations">Exceeding My Expectations <a class="permalink" href="#exceeding my_expectations">#</a></h2>
<p>Admittedly, I had pictured Ada’s syntax resembling the uncompromising verbosity and rigid construction of COBOL, or
	perhaps the Lovecraftian hieroglyphics of Fortran’s various eldritch incarnations. Turning the pages, I was pleasantly
	surprised by modern constructs associated with modern high-level languages such as ranges, slicing and
	exception-handling. The syntax — Admittedly verbose by modern standards<sup><a href="#footnote_3">3</a></sup> — seemed deliberately and purposefully
	constructed to make the language comprehensible at a glance.</p>
<p>The fact that Ada was designed with embedded-software in mind was of particular interest to me. I already had some
	limited experience with bare-metal development on the x86 and ARM platforms using C and assembly, so the prospect of
	using higher-level constructs on bare-metal seemed promising to me.</p>

<h2 id="not_the_camel_you_expected">Not the Camel You Expected <a class="permalink" href="#not_the_camel_you_expected">#</a></h2>
<p>A common pejorative refrain directed at Ada by its many detractors is that it is a language “designed by committee”,
	or even worse, a language “designed by committee <i>for the military</i>”<sup><a href="#footnote_1">1</a></sup>. The implication of which being that (so-called)
	design by committee precludes it from any real-world practicality. I contend that it is better to design a language to fit an
	existing problem domain than to pick your weapon of choice and set out in search of new problem domains to apply it
	to<sup><a href="#footnote_2">2</a></sup>. I will spare readers a detailed retelling of Ada’s conception within the Department of Defence’s <a href="http://archive.adaic.com/pol-hist/history/holwg-93/holwg-93.htm">‘High Order
	Language Working Group’</a>, save to say that the Ada programming language was born of the need for single, unified
	higher-level language suitable for use in the multitude of Real-Time Embedded systems developed by the DoD<sup><a href="#footnote_4">4</a></sup>. In the
	wise words of the working-group’s chair, Colonel William A. Whitaker: “It was concluded that no existing language
	could be adopted as a single common high order language for the DoD, but that a single language meeting essentially
	all the requirements was both feasible and desirable.”. If such a thing was indeed feasible, the DoD’s deep pockets
	would help it bring it into existence. Ironically, given its status as the de-facto standard language of modern embedded-system development, the C language was considered unsuitable for this purpose: “When Bell Labs were
	invited to evaluate C against the DoD requirements, they said that there was no chance of C meeting the requirements
	of readability, safety, etc.” (Whitaker, 1993). After its successful implementation, in what would prove a controversial decision, the DoD would go so far as to mandate 
	the use of Ada for all in-house software engineering.</p>

<h2 id="what_makes_it_so_good">So What Makes It Special? <a class="permalink" href="#what_makes_it_so_good">#</a></h2>
<p>
	Ada has many useful features that are of particular interest for low-level programming and operating-system development. One
	feature in particular that impressed me greatly was Ada’s <i>representation clauses</i> (see below). They provide a highly granular way to define the
	in-memory representation of low-level data structures. I was very quickly able to adapt my own long suffering operating-system development project to Ada, improving the
	quality of my codebase greatly in the process. The following section details some of Ada’s features:
</p>

<h3>Custom Types</h3>
<p>
	In addition to being a strongly typed language, Ada allows for the definition of new scalar, enumerated and record types.
	Custom primitive types can also be constrained to a predefined range of values.
	The example below demonstrates the definition of a new integer type based upon Ada’s native <code>Natural</code> type, restricted
	to a predefined range.
	The use of the subtype directive informs the compiler that other variables of the <code>Natural</code> type are compatible with
	the newly defined subtype.
</p>

<div class="code-block"><pre><span></span><span class="no">VGA_COL_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">80</span><span class="p">;</span>
<span class="no">VGA_ROW_COUNT</span> <span class="p">:</span> <span class="kr">constant</span> <span class="p">:=</span> <span class="mi">24</span><span class="p">;</span>

<span class="kd">subtype</span> <span class="kt">Col</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_COL_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">Row</span> <span class="kr">is</span> <span class="kt">Natural</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">VGA_ROW_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>

<p>
	The below example illustrates the creation of incompatible custom integer types. While their base type and range
	constraints are identical, Ada treats both as separate, incompatible types. An assignment of a variable of one type
	to the value of another is illegal, and will trigger a compile-time error.
</p>

<div class="code-block"><pre><span></span><span class="kd">type</span> <span class="kt">Integer_1</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Integer_2</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">A</span> <span class="p">:</span> <span class="n">Integer_1</span> <span class="p">:=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">B</span> <span class="p">:</span> <span class="n">Integer_2</span> <span class="p">:=</span> <span class="n">A</span><span class="p">;</span> <span class="c1">-- illegal!</span>
</pre></div>

<p>
	The following example demonstrates the creation of a custom enumerated type. It also demonstrates a subtype of an enumerated type with a constrained range of values.
</p>

<div class="code-block"><pre><span></span><span class="kd">type</span> <span class="kt">Day_Of_Week</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Monday</span><span class="p">,</span> <span class="nv">Tuesday</span><span class="p">,</span>
  <span class="nv">Wednesday</span><span class="p">,</span> <span class="nv">Thursday</span><span class="p">,</span> <span class="nv">Friday</span><span class="p">,</span> <span class="nv">Saturday</span><span class="p">,</span> <span class="nv">Sunday</span><span class="p">);</span>

<span class="kd">subtype</span> <span class="kt">Work_Day</span> <span class="kr">is</span> <span class="n">Day_Of_Week</span> <span class="kr">range</span> <span class="n">Monday</span> <span class="p">..</span> <span class="n">Friday</span><span class="p">;</span>
</pre></div>


<p>
	A variable with the type of <code>Work_Day</code> is restricted to its constrained range. Any attempt to assign a value outside
	of this range to a variable of this type will raise a <code>Constraint_Error</code> exception at runtime.
</p>

<h3>Representation Clauses</h3>
<p>
	Ada allows for explicitly defining the in-memory representation of scalar and compound types. The following example
	demonstrates the definition of a record type (equivalent to structures in C), as well as its associated
	representation in memory.
</p>

<div class="code-block"><pre><span></span><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The format of the System Table Descriptor pointer used by the processor</span>
<span class="c1">--  to load descriptor tables like the GDT and IDT.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">System_Table_Descriptor</span> <span class="kr">is</span>
   <span class="kr">record</span>
      <span class="n">Size</span>   <span class="p">:</span> <span class="n">Unsigned_16</span><span class="p">;</span>
      <span class="n">Offset</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span><span class="p">;</span>
   <span class="kr">end record</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">48</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">System_Table_Descriptor</span> <span class="kn">use</span>
   <span class="nn">record</span>
      <span class="n">Size</span>   <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span>  <span class="p">..</span> <span class="mi">15</span><span class="p">;</span>
      <span class="n">Offset</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">16</span> <span class="p">..</span> <span class="mi">47</span><span class="p">;</span>
   <span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>
</pre></div>

<p>
	The <code>Size</code> aspect specifier instructs the compiler that the <code>System_Table_Descriptor</code> type must be 48 bits in size. The
	record representation clause instructs the compiler as to the required layout of this record type in memory. This
	example specifies that the <code>Size</code> member should occupy bits 0 to 15, and the <code>Offset</code> member should occupy bits 16 to
	47. This feature is analogous to C’s bit-fields. The following example demonstrates defining the in-memory
	representation of an enumerated type.
</p>

<div class="code-block"><pre><span></span><span class="c1">----------------------------------------------------------------------------</span>
<span class="c1">--  The privilege level for a particular descriptor.</span>
<span class="c1">--  These correspond to the &#39;protection ring&#39; that this descriptor is</span>
<span class="c1">--  accessible from.</span>
<span class="c1">----------------------------------------------------------------------------</span>
<span class="kd">type</span> <span class="kt">Descriptor_Privilege_Level</span> <span class="kr">is</span> <span class="p">(</span>
   <span class="nv">Ring_0</span><span class="p">,</span>
   <span class="nv">Ring_1</span><span class="p">,</span>
   <span class="nv">Ring_2</span><span class="p">,</span>
   <span class="nv">Ring_3</span>
<span class="p">)</span>
<span class="kr">with</span> <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">Descriptor_Privilege_Level</span> <span class="kn">use</span> <span class="p">(</span>
   <span class="n">Ring_0</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">Ring_1</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">Ring_2</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">Ring_3</span> <span class="p">=&gt;</span> <span class="mi">3</span>
<span class="p">);</span>
</pre></div>


<p>
	The <code>Size</code> aspect specifier instructs the compiler that the <code>Descriptor_Privilege_Level</code> type must be 2 bits in size.
	The representation clause instructs the compiler as to required representation of each possible value of the
	enumerated type in memory. In this example the value of <code>Ring_0</code> will be represented by a value of <code>0x0</code> in memory, the
	value of <code>Ring_1</code> will be represented by <code>0x1</code>, and so on.
</p>

<h2 id="practical_example">A Practical Example <a class="permalink" href="#practical_example">#</a></h2>

<p>
	The following example, and accompanying comparison with C, demonstrates the configuration of a hypothetical UART device by interfacing with an 8-bit memory-mapped configuration register. 
	This example has been adapted from a presentation by AdaCore viewable <a href="https://www.youtube.com/watch?v=qvmDqbuQe-M">here</a>.
</p>

<div class="code-block"><pre><span></span><span class="kn">with</span> <span class="nn">System.Storage_Elements</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">System.Storage_Elements</span><span class="p">;</span>

<span class="c1">-------------------------------------------------------------------------------</span>
<span class="c1">--  Main</span>
<span class="c1">-------------------------------------------------------------------------------</span>
<span class="kd">procedure</span> <span class="nf">Main</span> <span class="kr">is</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Baud rate type.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Baud_Rate_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">b_9600</span><span class="p">,</span> <span class="nv">b_14400</span><span class="p">,</span> <span class="nv">b_115200</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Baud_Rate_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">b_9600</span>   <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">b_14400</span>  <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">b_115200</span> <span class="p">=&gt;</span> <span class="mi">7</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Parity Select Type</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">Parity_T</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">None</span><span class="p">,</span> <span class="nv">Even</span><span class="p">,</span> <span class="nv">Odd</span><span class="p">);</span>
   <span class="kr">for</span> <span class="n">Parity_T</span> <span class="kn">use</span> <span class="p">(</span>
     <span class="n">None</span> <span class="p">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
     <span class="n">Even</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
     <span class="n">Odd</span>  <span class="p">=&gt;</span> <span class="mi">2</span>
   <span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  Control Register for a hypothetical UART device.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="kd">type</span> <span class="kt">UART_Control_Register_T</span> <span class="kr">is</span>
      <span class="kr">record</span>
         <span class="n">Baud_Rate</span> <span class="p">:</span> <span class="n">Baud_Rate_T</span><span class="p">;</span>
         <span class="n">Parity</span>    <span class="p">:</span> <span class="n">Parity_T</span><span class="p">;</span>
         <span class="n">Unused</span>    <span class="p">:</span> <span class="kt">Boolean</span> <span class="p">:=</span> <span class="kc">False</span><span class="p">;</span>
         <span class="n">ISR</span>       <span class="p">:</span> <span class="kt">Boolean</span><span class="p">;</span>
      <span class="kr">end record</span>
   <span class="kr">with</span> <span class="n">Volatile_Full_Access</span><span class="p">,</span>
     <span class="n">Size</span> <span class="p">=&gt;</span> <span class="mi">8</span><span class="p">;</span>
   <span class="kr">for</span> <span class="n">UART_Control_Register_T</span> <span class="kn">use</span>
      <span class="nn">record</span>
         <span class="n">Baud_Rate</span> <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">2</span><span class="p">;</span>
         <span class="n">Parity</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">3</span> <span class="p">..</span> <span class="mi">4</span><span class="p">;</span>
         <span class="n">Unused</span>    <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">5</span> <span class="p">..</span> <span class="mi">6</span><span class="p">;</span>
         <span class="n">ISR</span>       <span class="kr">at</span> <span class="mi">0</span> <span class="kr">range</span> <span class="mi">7</span> <span class="p">..</span> <span class="mi">7</span><span class="p">;</span>
      <span class="kr">end</span> <span class="kr">record</span><span class="p">;</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The address of the UART control register.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="no">UART_CONTROL_REG_ADDR</span> <span class="p">:</span> <span class="kr">constant</span> <span class="n">System</span><span class="p">.</span><span class="kt">Address</span>
     <span class="p">:=</span> <span class="n">To_Address</span><span class="p">(</span><span class="mi">16</span><span class="err">#</span><span class="mi">8000_0040</span><span class="err">#</span><span class="p">);</span>

   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="c1">--  The UART control register itself.</span>
   <span class="c1">----------------------------------------------------------------------------</span>
   <span class="n">UART_Control_Register</span> <span class="p">:</span> <span class="n">UART_Control_Register_T</span>
   <span class="kn">with</span> <span class="nn">Import</span><span class="p">,</span>
     <span class="n">Convention</span> <span class="p">=&gt;</span> <span class="n">Ada</span><span class="p">,</span>
     <span class="kt">Address</span>    <span class="p">=&gt;</span> <span class="n">UART_CONTROL_REG_ADDR</span><span class="p">;</span>

<span class="kr">begin</span>
   <span class="c1">--  Configure the UART.</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Baud_Rate</span> <span class="p">:=</span> <span class="n">b_115200</span><span class="p">;</span>
   <span class="n">UART_Control_Register</span><span class="p">.</span><span class="n">Parity</span>    <span class="p">:=</span> <span class="n">Even</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Main</span><span class="p">;</span>
</pre></div>


<p>
	Contrast this with the same functionality implemented in C. Despite being shorter in length, the register cannot be altered without using bitwise operators to manipulate the individual fields. 
	This approach is generally considered more error-prone than using a record in Ada overlaid at the register’s memory-mapped address. 
	It is possible to define a struct type in C with bit-fields for the individual elements, however the C standard does not guarantee the layout 
	and order of the individual fields<sup><a href="#footnote_6">6</a></sup>.
</p>


<div class="code-block"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="cp">#define UART_CNTL_REG_ADDR       0x80000040</span>
<span class="cp">#define UART_CNTL_BAUD_MASK      0x07</span>
<span class="cp">#define UART_CNTL_BAUD_SHIFT     0</span>
<span class="cp">#define UART_CNTL_PARITY_MASK    0x18</span>
<span class="cp">#define UART_CNTL_PARITY_SHIFT   3</span>
<span class="cp">#define UART_CNTL_IE_MASK        0x80</span>
<span class="cp">#define UART_CNTL_BAUD_9600      0</span>
<span class="cp">#define UART_CNTL_BAUD_14400     1</span>
<span class="cp">#define UART_CNTL_BAUD_115200    7</span>
<span class="cp">#define UART_CNTL_PARITY_NONE    0</span>
<span class="cp">#define UART_CNTL_PARITY_EVEN    1</span>
<span class="cp">#define UART_CNTL_PARITY_ODD     2</span>
<span class="cp">#define UART_CNTL_ISR_ENABLE     2</span>
<span class="cp">#define UART_CNTL_ISR_DISABLE    2</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/** The UART control register pointer. */</span>
	<span class="kt">volatile uint8_t</span> <span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">UART_CNTL_REG_ADDR</span><span class="p">;</span>

	<span class="c1">// Configure the UART.</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_CNTL_BAUD_MASK</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">|=</span> <span class="n">UART_CNTL_BAUD_115200</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_CNTL_PARITY_MASK</span><span class="p">;</span>
	<span class="o">*</span><span class="n">uart_control_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_CNTL_PARITY_EVEN</span> <span class="o">&lt;&lt;</span> <span class="n">UART_CNTL_PARITY_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="the_bad">The Bad and the Ugly <a class="permalink" href="#the_bad">#</a></h2>
<p>No programming language is perfect, and Ada is no exception. I preface this section by freely admitting that I am by no means an expert in the Ada programming language.
	Some of these (minor) complaints could be perfectly explained by my naiveté of established conventions and inexperience with the language.
</p>
<p>
	<b>Poor pointer semantics</b> – The requirement to declare a pointer-to-type as a new type feels especially onerous.
	However contextually intuitive the act of declaring a distinct pointer type may be to the compiler, it provides an
	unnecessary burden to the programmer. Conversion to and from — and subsequent dereferencing of — pointers is
	unnecessarily cumbersome. Needing to instantiate the generic library <a href="https://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-7-2.html"><code>Address_To_Access_Conversions</code></a> to 
	do something as simple as
	creating a pointer from an arbitrary address seems like unnecessary overkill.
	All this being said, I like the semantic intuitiveness of Ada’s <i>access types</i>, in contrast to C’s pointers. The
	noted absence of pointer arithmetic is very welcome: <i>Access types</i> in Ada are not a numeric type in any form.
	They point to a memory address, and allow <i>access</i> to the value located there. Simple, sensible. Perhaps these minor
	inconveniences are simply the consequence of integrating a low-level concept like pointers into higher-level
	language constructs. For reasons like this, Ada is hard to place on this continuum. Despite the presence
	of many higher-level constructs such as ranges, fat-pointers and object-orientation, Ada is a language principally oriented around low-level concerns, which is a perfect segue into my second issue...
</p>
<p>
	<b>The runtime</b> – In addition to implementing Ada’s standard library, the Ada’s runtime
	fulfils important functions at runtime, such as range checks on constained types. Comprehensive knowledge of the Ada
	runtime and its structure is required for the use of even moderately high-level
	language constructs on a platform.
	I will admit being unaccustomed to being concerned with a language’s runtime library when targeting bare-metal. I
	found the process of implementing my own runtime library for a bare-metal target
	to be particularly unintuitive. When beginning the <a href="https://github.com/ajxs/cxos">CXOS</a> project, my
	compiler did not ship with a
	suitable <i>zero-footprint</i> runtime library for the x86 platform. As a result I was forced to learn the process of
	implementing a bare-metal x86 runtime for myself. The equivalent process of putting together the build
	pipeline and infrastructure for a bare-metal C environment is much more straightforward.
	The ability to make highly granular modifications to the language’s runtime is extremely useful for deployments on
	platforms with limited resources or functionality, however the complicated nature of this process serves as a barrier
	to uptake that other language’s may not have. This
	is by no means an insurmountable problem, albeit one that I found particular time consuming.
	I put together a comprehensive guide to setting up an Ada runtime library suitable for operating system development on
	the x86 platform, which can be viewed <a href="https://wiki.osdev.org/Ada_Runtime_Library">here</a>.
</p>

<p>
	Despite my minor misgivings, my experiences with Ada remain positive overall. More than once I’ve heard online
	detractors accuse Ada of having aged poorly, or excuse it on the basis that it was a
	product of its age: A historical artefact to be taken as-is, not to be judged by today’s — impliedly higher —
	standards. In rebuttal I contend that the fact that a modern developer can recognise in Ada many of the
	high level constructs thought to be revolutionary in modern scripting languages indicates that it is in fact the programming
	ecosystem on the whole that’s aged poorly. I can’t help but think that complicated programming paradigms would seem more intuitive
	to beginners if taught through Ada instead of C and its derivative languages, as is common in computer science and engineering faculties worldwide.
</p>

<h2 id="whats_next">What’s Next, and What Have We Learned? <a class="permalink" href="#whats_next">#</a></h2>
<p>Rumors of Ada’s demise remain exaggerated, decades later. Mere years after the DoD Ada mandate had been lifted<sup><a href="#footnote_7">7</a></sup>, Lockheed Martin’s
	choice to forgo Ada as the language of choice for the development of
	the benighted F-35 Joint Strike Fighter in lieu of a heavily abridged dialect of C++<sup><a href="#footnote_5">5</a></sup>  was for many the definitive sign that the bell tolled for Ada. John H. Robb,
	the Senior Manager of the F-35 Joint Strike Fighter Air Vehicle Software team at Lockheed Martin Aeronautics Fort
	Worth <a href="https://web.archive.org/web/20111219004314/http://journal.thedacs.com:80/issue/53/158">writes on the subject</a>: “Ada was seen as the technically superior and more robust language, but
	concern over the ability to successfully staff the software engineers required to develop the massive amounts of
	safety critical software caused the F-35 team to carefully look and finally to choose C and C++ for the implementation
	of safety critical software.” For Ada fans this statement is bittersweet indeed. The proof of
	the pudding however remains in the tasting. Reports from 2016 indicated that the <i>Block 3i</i> avionics software loaded
	onto the F-35 was so problematic that it required rebooting on average every 4 hours (flightglobal.com, 2016). The historical record will likely prove kinder to Ada than its critics.</p>

<p>
	For all the water-cooler chatter of obsolescence, Ada enjoys serious respect in industries where failure is not an option. Nvidia <a href="https://www.adacore.com/company/partners/nvidia">recently</a> chose 
	Ada and its SPARK subset<sup><a href="#footnote_8">8</a></sup> as their language of choice for development of safety-critical firmware in their embedded-systems. 
	Some other notable users of Ada include the European Space Agency<sup><a href="#footnote_9">9</a></sup>, BAE Systems, Saab, Thales, and <a href="http://archive.adaic.com/projects/atwork/boeing.html">Boeing</a>. 
	A quick glance at leading Ada compiler manufacturer AdaCore’s <a href="https://www.adacore.com/company/our-customers">customer list</a> demonstrates that the market for Ada is certainly alive and well. 
	The verdict is in: <i>Ada is here to stay</i>.
</p>

<p>
	Many developers point to Rust as the systems programming language of the future. Rust is a language that markets itself on its focus on <i>safety</i><sup><a href="#footnote_10">10</a></sup>, which 
	invites comparisons against both C and Ada (for vastly different reasons). Superficial comparisons aside, Rust seems like a language that has neither
	learned much from C’s failures, nor from Ada’s successes. Despite what the Rust community may say (or the algal bloom of osdev projects in Rust), Rust does not seem well adapted to low-level programming: 
	It lacks basic features necessary for the task, like bitfields, and data structure packing. Its foreign function interface seems particularly poorly implemented. The <a href="https://doc.rust-lang.org/nomicon/ffi.html">official Rust documentation</a> suggests 
	the use of the external third-party <code>libc</code> library (called a 'crate' in Rust parlance) 
	to provide the type definitions necessary to interface with C programs. As of the time of writing, this crate has had <a href="https://crates.io/crates/libc/versions">95 releases</a><sup><a href="#footnote_11">11</a></sup>. 
	Contrast this with Ada’s <code>Interfaces.C</code> package, which was added the language in Ada 95 and hasn’t needed to change in any fundamental way since.
	Despite Rust’s present shortcomings, it could prove to be a capable language that has much to offer if it can manage to standardise itself and evolve in a sensible way<sup><a href="#footnote_12">12</a></sup>.
</p>

<p>I am nothing if not an idealist. For better or worse, I have been willing to pick for myself the smallest hills to
	die on in matters of technical dispute. When push comes to shove however, it pays to be pragmatic. It is true of
	course, that any fully-featured systems programming language can be utilised in a safety-critical manner. As John H.
	Robb himself so eloquently notes in the aforementioned article: “...the basic elements required to make a language work in [the
	safety-critical] domain are persistence, determination, and good software engineering discipline”. This is of course
	true, however the qualities he mentions are valuable commodities indeed. If persistence, determination, and discipline
	are to be requirements, then why not choose a language that requires less of such rigor in order to achieve the same high-quality results? 
	After all, software is certainly easier to <a href="https://en.wikipedia.org/wiki/Morris_worm">get</a> 
	<a href="https://nvd.nist.gov/vuln/detail/CVE-2019-3568">wrong</a> than it is to get right.</p>

<hr />
<h2 id="references">References <a class="permalink" href="#references">#</a></h2>

<p>Flightglobal (2016) F-35 locked and loaded with improved Block 3i software. Retrieved 12 Jan, 2021, from <a href="https://www.flightglobal.com/f-35-locked-and-loaded-with-improved-block-3i-software/120527.article">https://www.flightglobal.com/f-35-locked-and-loaded-with-improved-block-3i-software/120527.article</a></p>
<p>William A. Whitaker (1993). Ada - The Project, The DoD High Order Language Working Group. <i>ACM SIGPLAN Notices</i> Vol. 28, No. 3, March 1993.</p>

<hr />
<ol class="footnotes">
	<li id="footnote_1">
		It is worth noting that in the days of Ada’s conception the United States military, or at very least their
		government, could have very well been the chief developer and consumer of high-assurance embedded systems worldwide.
		If there was to be any paradigm shift in the developmental methodology of such systems, it would seem likely that it
		would come from this sector.
	</li>
	<li id="footnote_2">
		A la Javascript.
	</li>
	<li id="footnote_3">
		In comparison to the plethora of modern languages that count C as an ancestor.
	</li>
	<li id="footnote_4">
		The oft-repeated claim that embedded development within the DoD was plagued by a troublesome and mountainous plurality
		of different languages has been anecdotally disputed online, usually by Ada’s detractors. Even if this were not true, I
		find it hard to believe that JOVIAL would be a more ideal standardised language for future projects.
	</li>
	<li id="footnote_5">
		The Joint Strike Fighter Air Vehicle (AV) C++ Rules were developed by Lockheed Martin to create a dialect of C++
		compatible with safety-critical software engineering. Bjarne Stroustrup hosts a copy of the guidelines on his
		website: <a href="https://www.stroustrup.com/JSF-AV-rules.pdf">https://www.stroustrup.com/JSF-AV-rules.pdf</a>.
	</li>
	<li id="footnote_6">
		Refer to section 6.7.2.1 paragraph 11 of the C1X standard.
	</li>
	<li id="footnote_7">
		It is worth mentioning that a common criticism of the DoD’s Ada mandate was the technical difficulty of writing and compiling Ada in its early days. 
		An oft-cited cause of such difficulties was the technical challenge of implementing a compiler for the language on contemporary hardware. Ada's 
		current de-facto standard compiler <i>GNAT</i> — based on the FSF's GCC compiler — was officially launched in 1995. Historical accounts of
		Ada's early development tell of long compilation times on expensive proprietary compiler infrastructure. The high cost of said 
		compilers were ostensibly another barrier to Ada's mainstream adoption. It's also worth noting that by the time the DoD’s mandate on Ada was lifted the DoD
		had largely shifted its focus towards the use of <a href="https://en.wikipedia.org/wiki/Commercial_off-the-shelf"><i>COTS</i></a> (Commercial Off The Shelf) software. As a result, the
		lifting of the mandate probably had a much lesser impact than people suppose.
	</li>
	<li id="footnote_8">
		<a href="https://en.wikipedia.org/wiki/SPARK_(programming_language)">SPARK</a> is a formally-provable subset of Ada. SPARK reduces the scope of the language to
		a strict subset for which formal verification of lack of runtime errors is possible.
	</li>
	<li id="footnote_9">
		Whenever the topic of Ada arises on Hacker News, there's inevitably someone smugly bringing up the 
		failure of the first test flight of the European Space Agency's <i>Ariane V</i> rocket as though it were some searing indictment of the Ada programming language.
		Without delving unnecessarily far into a subject about which a <a href="https://www.bugsnag.com/blog/bug-day-ariane-5-disaster">wealth</a> <a href="https://www.dropbox.com/s/tr02fmo4xzytzhv/Bashar-Ariane5.pdf?dl=0">of</a> 
		<a href="http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html">material</a> has already been written, it is suffice say that Ada can be spared the blame for this accident.
		Evidence supports the crash having been caused by <em>poor design practices</em>, the end. 
		Despite the wealth of evidence exonerating the language, <a href="https://news.ycombinator.com/item?id=20935953">some people</a> will simply never get it, and conjecture persists in the face of common sense.
	</li>
	<li id="footnote_10">
		<i>Safety</i> is a different concept than being suitable for <i>safety-critical</i> applications. Rust is designed principally around the elimination of the kind of memory bugs associated 
		with the C programming language, such as <i>use after free</i>, <i>buffer overflow</i> and <i>memory leaking</i>, among others.
	</li>
	<li id="footnote_11">
		This begs the question: <i>what about an C interface requires this much work?</i> Admittedly the <code>libc</code> crate ostensibly provides a very broad scope of functionality.
		Their <a href="https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md">official RFC</a> states the opposite: “The primary purpose of this crate is to provide all of the 
		definitions necessary to easily interoperate with C code (or “C-like“ code) on each of the platforms that Rust supports.“, indicating a narrow scope of requirements.
		However browsing the <a href="https://github.com/rust-lang/libc/issues">Issues</a> section their Github gives the opposite impression. Either way, interoperability (in my experience) 
		remains dysfunctional at best.
	</li>
	<li id="footnote_12">
		Rust, which as of the time of writing has yet to be formally standardised, seems to have a very wide variety of hands on the wheel. Rust’s core community ostensibly appears to be a collection of refugees
		from the Node.js and Golang communities. It enjoys an active and enthusiastic community. Despite my misgivings about some of Rust’s design decisions, I can see its benefits. For companies such as Mozilla,
		migrating their products from C++ to Rust seems like a great idea.
	</li>
</ol>
	</div>
</article>

		<footer>
				© 2022 AJXS
		</footer>
	</body>
</html>
