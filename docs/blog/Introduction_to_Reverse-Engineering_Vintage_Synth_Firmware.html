<!DOCTYPE html>
<html lang="en">
	<head>
				<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="author" content="ajxs">
		<meta name="description" content="A gentle introduction to reverse-engineering vintage synthesiser ROMs using the Ghidra disassembler.">
		<meta name="robots" content="index, follow">
		<meta name="keywords" content="ajxs,synthesisers,programming,DX7,Musical Equipment,Reverse Engineering,Synthesizers">
		<meta name="reply-to" content="ajxs@panoptic.online">
		<meta name="owner" content="ajxs">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" type="text/css" href="/static/style.css">
		<link rel="stylesheet" type="text/css" href="/static/code.css">
		<link rel="alternate" type="application/rss+xml" title="Blog Posts" href="/site.rss">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/img/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicon-16x16.png">

		<title>~ajxs/Introduction to Reverse-Engineering Vintage Synth Firmware</title>
				
	</head>
	<body>
		<header>
			<a href="/">~ajxs</a>
		</header>
		<article class="blog-entry">
	<header>
		<h1>Introduction to Reverse-Engineering Vintage Synth Firmware</h1>
		<div class="date">2024.03.18</div>
		<div class="description">A gentle introduction to reverse-engineering vintage synthesiser ROMs using the Ghidra disassembler.</div>
							<div class="tags">
				<span>Tagged as: </span>
				<ul class="tag-list">
							<li><a href="/blog/tag/DX7.html">DX7</a></li>
							<li><a href="/blog/tag/Musical_Equipment.html">Musical Equipment</a></li>
							<li><a href="/blog/tag/Reverse_Engineering.html">Reverse Engineering</a></li>
							<li><a href="/blog/tag/Synthesizers.html">Synthesizers</a></li>
					</ul>
			</div>
			</header>
	<div class="entry-body">
			<p>
		In this article we're going to take a look at how to reverse-engineer vintage synthesiser firmware.
		The synthesiser I've chosen for us to look at is the Yamaha DX7 
		(<i>See <a href="#why_the_dx7">Appendix: Why Choose This Synth?</a></i>). 
		You don't need a DX7 to follow along at home, 
		but you will need a copy of the DX7 V1.8 firmware 
		(available
		<a href="https://dbwbp.com/index.php/9-misc/37-synth-eprom-dumps" target="_blank">here</a>)
		and the
		<a href="https://ghidra-sre.org/" target="_blank">Ghidra</a> disassembler.
	</p>
	<div class="note">
		<p>
			<span class="heading">Who is this article for?</span>
			This article's intended audience is people from a technical background who are new to reverse-engineering, 
			8-bit architectures, or embedded development.
			If you come from an electrical-engineering or embedded-software background, 
			you'll probably find the content here a little basic.
		</p>
		<p>
			You'll only need to know a little bit about low-level programming:
			A basic understanding of how binary and pointers work should be enough.
			You don't need to know assembly language,
			or understand any specific processor architecture.
		</p>
	</div>
	<p>
		A few years ago I decided to give myself a crash course on what goes on inside synthesisers.
		I ended up writing the article
		<a href="/blog/Yamaha_DX7_Technical_Analysis.html" target="_blank">Yamaha DX7 Technical Analysis</a>
		about what I'd learned.
		In order to tease out some more details about the DX7's inner-workings, 
		I decided to 
		<a href="https://github.com/ajxs/yamaha_dx7_rom_disassembly" target="_blank">disassemble the synth's firmware ROM</a>.
		I didn't have any experience with reverse-engineering binaries,
		so I had to figure it out as I went.
		I'm still by no means an expert 
		(<i>if you see any mistakes in this article, please let me know!</i>),
		but I'd like to share what I've learned.
	</p>
	<p>
		All I had when I started was a copy of the firmware,
		a copy of the service manual,
		and a <i>can-do</i> attitude.
		I knew nothing about 8-bit systems, 
		and <em>absolutely nothing</em> about electronics,
		but I was willing to give anything a shot.
		If this sounds like you, read on, and I hope you find this article helpful!
	</p>

	<div class="table-of-contents colour_mid-bg">
		<div class="table-of-contents-title">Table of Contents</div>
		<ol>
			<li><a href="#address_decoding">Address Decoding</a></li>
			<li><a href="#memory_map">Decoding the DX7's Memory Map</a>
				<ol>
					<li><a href="#rom_address_decoding">The Firmware ROM</a></li>
					<li><a href="#ram_address_decoding">RAM</a></li>
					<li><a href="#lcd_address_decoding">LCD Screen</a></li>
					<li><a href="#wrapping_up">Wrapping Up</a></li>
				</ol>
			</li>
			<li><a href="#disassembling_the_firmware">Disassembling The Firmware</a>
				<ol>
					<li><a href="#reset_function">The Reset Function</a></li>
					<li><a href="#interrupts">Interrupts</a></li>
					<li><a href="#lcd_interface">LCD Interface</a></li>
				</ol>
			</li>
			<li><a href="#going_further">Going Further</a>
				<ol>
					<li><a href="#midi_handling_routine">The MIDI Handling Routine</a></li>
					<li><a href="#interrupts">Debugging the Firmware in an Emulator</a></li>
					<li><a href="#final_words">Final Words</a></li>
				</ol>
			</li>
			<li><a href="#why_the_dx7">Appendix: Why Choose This Synth?</a></li>
			<li><a href="#documentation">Appendix: Documentation</a></li>
		</ol>
	</div>

	<p>
		Reverse-engineering vintage synthesisers is a great introduction to embedded systems,
		and can be a lot of fun.
		In a lot of ways reverse-engineering is a bit like putting together a big jigsaw puzzle.
		Sometimes putting a new piece in place unlocks a lot of new progress,
		and like a jigsaw puzzle, the best place to start is at the edges.
	</p>

	<h2 id="address_decoding">Address Decoding <a class="permalink" href="#address_decoding">#</a></h2>
	<p>
		The peripheral devices attached to the DX7's CPU,
		such as its LCD screen and sound chips,
		are <i>memory-mapped</i>.
		This means that the device has been allocated a specific address range in the system's memory,
		and the system communicates with the device by reading and writing data from and to these addresses.
	</p>
	<p>
		Before we can start disassembling the firmware ROM, 
		we need to know what peripheral device is mapped where.
		To do that we'll need to look at the DX7's <i>address decoding</i> logic.
		The first place to start is with the schematics.
	</p>
	<p>
		The best version of the schematics I've seen is
		<a href="https://yamahamusicians.com/forum/viewtopic.php?p=90769#p90769" target="_blank">this</a>
		version, created by the yamahamusicians.com user <i>Miks</i>.
		While you're at it, grab a copy of the
		<a href="https://homepages.abdn.ac.uk/d.j.benson/pages/dx7/manuals/dx7-9_service_manual_1.pdf" target="_blank">service manual</a> too.
		We won't be referencing it in this article, but it's a good resource to have.
		It explains certain details about the synth's architecture that aren't obvious from the schematics.
	</p>
	<div class="note">
		<span class="heading">Service Manuals:</span>
		Most consumer devices from the 80s and 90s have <i>service manuals</i> available.
		These are technical documents written by the manufacturer to assist in servicing the device.
		They typically include schematics, diagrams, and lists of electrical components.
		The first place to start when reverse-engineering a device is looking for its service manual.
	</div>
	<p>
		If you're new to electronics, device schematics can look very intimidating,
		but once you understand the basics they're not actually as scary as they look!
		You can find a good introductory guide to schematics
		<a href="https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all" target="_blank">here</a>.
	</p>

	<h3>Background</h3>
	<p>
		But first, what does <i>address decoding</i> actually mean?
		<a href="https://en.wikipedia.org/wiki/Address_decoder" target="_blank">Address decoding</a>
		refers to <em>how</em> a specific device is mapped to a specific address.
		In this section we'll figure out what peripheral is mapped to what address by 
		tracing the address decoding logic in the synth's schematics.
	</p>
	<p>
		The total amount of memory addresses that a CPU can access is referred to as the CPU's <i>'address space'</i>.
		This is limited by the <i>width</i> of its <i>'address bus'</i>.
		The CPU's address bus is responsible for selecting addresses in attached memory devices, 
		such as RAM, or peripheral devices with addressable registers.
		Each <i>line</i> in the address bus represents a single bit, 
		with the total number of lines determining the address range the CPU can access.
		For example, a 16-bit address bus can address 2<sup>16</sup> unique memory locations, or 64KiB.
	</p>
	<p>
		When a CPU's address lines are exposed externally in the form of pins on the chip's package,
		this is called an <i>external</i> address bus<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>.
		These lines can be physically connected to external memory devices.
		Together with the CPU's <i>data bus</i>,
		this allow reading and writing binary data back and forth.
	</p>
	<p>
		When the CPU performs an instruction that reads or writes memory, like <code>LDB 0x2001</code>,
		several things happen:
		</p><ul>
			<li>
				The CPU's external address pins are set to high and low 
				<a href="https://en.wikipedia.org/wiki/Logic_level" target="_blank">logic levels</a>
				according to the specified address.
				For address <span class="hex-address">0x2001</span> (<code>0b0010_0000_0000_0001</code>), 
				address pins 0 and 13 will be high, 
				and all the others will be low.
			</li>
			<li>
				The CPU's <code class="active-low">RW</code> 
				pin will be set high to indicate that this is a <i>read</i> operation, and...
			</li>
			<li>
				The CPU will prepare to accept the incoming data at <span class="hex-address">0x2001</span> 
				over the data bus into the <span class="register-name">B</span> register.
			</li>
		</ul>
	
	<p>
		But wait... If the CPU only has one set of address and data bus lines, 
		how do you connect multiple memory devices to the CPU?
		This is where the 
		<a href="https://en.wikipedia.org/wiki/Chip_select" target="_blank"><i>'Chip Select'</i></a>
		interface comes in:
		Each device attached to the CPU's data/address buses has a 'Chip Select' pin,
		controlling whether the device responds to incoming signals.
	</p>
	<p>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/address_decoding_logic.png" target="_blank">
			<img alt="A schematic showing the address decoding logic of a hypothetical system." src="/static/img/articles/reverse_engineering_vintage_synths/address_decoding_logic_thumbnail.jpg">
		</a>
		Consider the above (incredibly simplified) diagram:
		Two 8KiB 
		<a href="https://en.wikipedia.org/wiki/6264" target="_blank">6264</a>
		RAM chips (U3 and U4) are connected to shared address and data buses on a Z80 CPU.
		U3's <code class="active-low">CE1</code> (Chip Enable) pin is connected to the CPU's A13 pin.
		The bar over the top of the label indicates that this pin is <i>'Active Low'</i>,
		meaning a low logic level will 'activate' its function.
		When the CPU selects an address between 
		<span class="hex-address">0x0</span> and <span class="hex-address">0x1FFF</span>, 
		the A13 pin will be low, activating the U3 chip.
		U4's <code class="active-low">CE1</code> 
		pin is attached to the CPU's A13 pin via a <code>NOT</code> gate, 
		which inverts the signal coming from A13.
		When an address above <span class="hex-address">0x1FFF</span> is selected, A13 will be set high, 
		selecting the U4 chip.
		This effectively maps U3 to the first 8KiB of the system's memory, 
		and U4 to the next.
	</p>
	<p>
		Can you spot the problem with this example?
		Since <em>any</em> address using A13 will 'select' U4, 
		U4 is now mapped to <em>every</em> 8KiB block of memory above <span class="hex-address">0x1FFF</span>.
		In reality, more sophisticated logic is used to map memory devices.
		Let's examine the real world example of the DX7's address decoding circuitry.
	</p>

	<div class="note">
		<span class="heading">Logic Gates:</span>
		The DX7's <i>address decoding logic</i> is primarily implemented via the use of <i>logic gates</i>.
		If you're not familiar with logic gates,
		a good introduction to the topic can be found 
		<a href="https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:computers/xcae6f4a7ff015e7d:logic-gates-and-circuits/a/logic-gates" target="_blank">here</a>.
		Don't worry though, we're not going to be going too in-depth.
		A basic understanding of what <code>AND</code>, <code>OR</code>,
		and <code>NOT</code> gates do is all you need.
		One particular type of component you'll encounter a lot inside vintage synthesisers are
		<a href="https://en.wikipedia.org/wiki/7400-series_integrated_circuits" target="_blank">7400-series logic chips</a>.
	</div>

	<h2 id="memory_map">Decoding the DX7's Memory Map <a class="permalink" href="#memory_map">#</a></h2>
	<p>
		Nearly all of the discrete electrical components that make up a DX7 are commonly available products.
		They're mass-manufactured and sold by a variety of different manufacturers.
		The best way to understand these components is to read the <i>datasheets</i> made available by the manufacturer.
		I'll provide links to these as we go.
	</p>
	<div class="note">
		<span class="heading">Note:</span>
		The creator of the DX7 schematics used the <i>logic</i> symbols &#183; and + to denote 
		<code>AND</code> and <code>OR</code> gates,
		rather than the more standard 
		<a href="https://www.electrical-symbols.com/electrical-electronics-pdf/Logic_Gates_Symbols.pdf" target="_blank">
			ANSI, or IEC notations
		</a><sup>[pdf]</sup>.
		Other gates use the ANSI notation.
	</div>
	<h3 id="rom_address_decoding">The Firmware ROM <a class="permalink" href="#rom_address_decoding">#</a></h3>
	<p>
		Let's start by taking a look at the firmware ROM, IC14.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/schematics/rom.png" target="_blank">
			<img alt="An excerpt from the Yamaha DX7's schematics, with the ROM address mapping logic highlighted" src="/static/img/articles/reverse_engineering_vintage_synths/schematics/rom_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Yamaha DX7's schematics, with the ROM address mapping logic highlighted.
		</figcaption>
	</figure>
	<p>
		In the schematic we can see that IC14's <code class="active-low">CE1</code> 
		pin is connected to the CPU's <code>A14/A15</code> lines via an <code>AND</code> gate, and a <code>NOT</code> gate.
		What's going on here?
	</p>
	<p>
		The <code>AND</code> gate ensures that the signal is only high when <em>both</em> address lines are active,
		and the <code>NOT</code> gate inverts the signal so that it activates the 
		<em>active-low</em> <code class="active-low">CE1</code> pin.
		If <code>A14</code> and <code>A15</code> being active on the CPU 'selects' the ROM chip, 
		that means it's mapped to the address range <span class="hex-address">0xC000 - 0xFFFF</span><sup><a href="#footnote_2" id="footnote_2_link">2</a></sup>.
	</p>
	<p>
		Awesome! That wasn't so hard. Now we know where the ROM is mapped in memory. What's next?
	</p>

	<h3 id="ram_address_decoding">RAM <a class="permalink" href="#ram_address_decoding">#</a>
	</h3><p>
		The address decoding logic for the RAM is a little more complicated.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/schematics/ram.png" target="_blank">
			<img alt="An excerpt from the Yamaha DX7's schematics, with the RAM address mapping logic highlighted" src="/static/img/articles/reverse_engineering_vintage_synths/schematics/ram_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Yamaha DX7's schematics, with the RAM address mapping logic highlighted.
		</figcaption>
	</figure>
	<p>
		The DX7 features three 4KiB 
		<a href="https://www.allaboutcircuits.com/electronic-components/datasheet/M5M5118P--Mitsubishi/" target="_blank">5118P</a>
		RAM chips (IC19, 20, 21).
		These are connected to the CPU's address bus via a 
		<a href="https://www.ti.com/product/SN74LS138" target="_blank">74LS138 demultiplexer</a>
		(IC23).
		This 
		<a href="https://www.electronics-tutorials.ws/combination/comb_3.html" target="_blank">demultiplexing</a>
		circuit is used to select one of 8 individual output lines based on a 3-bit input signal.
		These output lines are labeled as <code class="active-low">Y<sub>0</sub></code> - <code class="active-low">Y<sub>7</sub></code>,
		and the input lines as <code>D<sub>A</sub></code>, <code>D<sub>B</sub></code>, and <code>D<sub>C</sub></code>.
		The <code>OR</code> gates used here are wired to the system clock output pin.
		Presumably to ensure the timing of read and write operations are valid.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/74ls138_function_table.png" target="_blank">
			<img alt="The function table from the 74LS138P's datasheet" src="/static/img/articles/reverse_engineering_vintage_synths/74ls138_function_table_thumbnail.jpg">
		</a>
		<figcaption>
			The 'Function Table' from the 74LS138P's datasheet, 
			showing what combinations of input lines select which output line.
		</figcaption>
	</figure>
	<p>
		The first RAM chip (IC19)'s chip select terminal is connected to the demultiplexer's 
		<code class="active-low">Y<sub>2</sub></code> line.
		The 'Function Table' from the 74LS138P datasheet shows that <code class="active-low">Y<sub>2</sub></code>
		will be set low when input <code>D<sub>B</sub></code> (connected to the CPU's <code>A12</code>) is high.
		Therefore, when the CPU selects address <span class="hex-address">0x1000</span>,
		the first RAM chip will be selected.
	</p>
	<p>
		<code class="active-low">Y<sub>3</sub></code>
		(connected to the second RAM chip, IC20) will be set low when inputs 
		<code>D<sub>A</sub></code> and <code>D<sub>B</sub></code>
		(<code>A11</code> and <code>A12</code>) are high,
		corresponding to an address of <span class="hex-address">0x1800</span>.
		Likewise, <code class="active-low">Y<sub>4</sub></code> 
		(connected to IC21) corresponds to an address of 
		<span class="hex-address">0x2000</span>.
	</p>
	<p>
		By tracing this address decoding logic, we've successfully mapped the synth's RAM to 
		<span class="hex-address">0x1000 - 0x2800</span>.
	</p>

	<h3 id="lcd_address_decoding">LCD Screen <a class="permalink" href="#lcd_address_decoding">#</a></h3>
	<p>
		The last peripheral we're going to look at right now is the synth's LCD screen.
		When you take your first peek inside a binary you'll be staring at an intimidating jumble of machine code.
		One of the few things that will stand out at a glance is ASCII strings.
		A good way to get a quick overview of the binary is finding out how these strings are printed to the screen, and where.
	</p>
	<p>
		The best place to start doing that is understanding how the CPU interfaces with the LCD controller,
		and working your way backwards to the code responsible for sending string data to it.
		Once you've found <em>how</em> strings are printed to the screen,
		you can easily see <em>what's</em> printed <em>where</em> to get a better understanding of the code.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/schematics/lcd.png" target="_blank">
			<img alt="An excerpt from the Yamaha DX7's schematics, with the LCD address mapping logic highlighted" src="/static/img/articles/reverse_engineering_vintage_synths/schematics/lcd_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Yamaha DX7's schematics, with the LCD address mapping logic highlighted.
		</figcaption>
	</figure>
	<p>
		The LCD address mapping logic might look really complicated, but don't worry though. 
		It's just more of the same logic as before.
	</p>
	<p>
		IC23's <code class="active-low">Y<sub>5</sub></code> pin is connected to IC24, another 74LS138 demultiplexer.
		From the 74LS138 function table we know that <code class="active-low">Y<sub>5</sub></code> 
		goes low when inputs A, and C (<code>A11</code> and <code>A13</code>) are high.
		So it looks like IC24 is mapped to <span class="hex-address">0x2800</span>.
	</p>
	<p>
		Take a look at IC24: Inputs A, B and C are wired to 
		<code>A1</code>, <code>A2</code> and <code>A3</code>.
		That means that IC24 only maps <em>8 bytes</em>.
	</p>
	<p>
		IC24's <code class="active-low">Y<sub>0</sub></code> and <code class="active-low">Y<sub>1</sub></code>
		pins are connected to an <code>AND</code> gate connected to the 'chip select' pin of IC12.
		What's happening here?
		This might seem a little confusing at first,
		but since the 74LS138P's outputs are <i>active-low</i>, 
		this makes <code class="active-low">LCDCS</code> active when either
		<code class="active-low">Y<sub>0</sub></code> or <code class="active-low">Y<sub>1</sub></code>
		are active. This maps IC12 to the four-byte range <span class="hex-address">0x2800 - 0x2803</span>.
		Awesome. But what's IC12 doing?
	</p>
	<p>
		IC12 is an 
		<a href="https://en.wikipedia.org/wiki/Intel_8255" target="_blank">Intel 8255</a>
		<i>Programmable Peripheral Interface (PPI)</i>.
		It provides 24 parallel, bidirectional IO lines<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/8255_basic_operation.png" target="_blank">
			<img alt="An excerpt from the Intel 8255 datasheet showing its basic operations" src="/static/img/articles/reverse_engineering_vintage_synths/8255_basic_operation_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Intel 8255 datasheet showing its basic operations.
		</figcaption>
	</figure>
	<p>
		The schematics show the LCD's parallel interface (<code>DB0 - DB7</code>) is
		connected to the PPI's port A (<code>PA0 - PA7</code>), 
		and its control pins (<code>E, RW</code> and <code>RS</code>)
		to the PPI's port B (<code>PB0 - PB2</code>).
	</p>
	<p>
		The Hitachi LM016 LCD screen used in the DX7 features the ubiquitous 
		<i><a href="https://en.wikipedia.org/wiki/Hitachi_HD44780_LCD_controller" target="_blank">Hitachi HD44780 LCD Controller</a></i>.
		According to its datasheet
		(available <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf" target="_blank">here</a>)
		it has two registers.
		When its <code>RS</code> line (connected to the PPI's <code>PB0</code>)
		is low, the <i>instruction register</i> is selected.
		When high, the <i>data register</i> is selected.
	</p>
	<p>
		Based on the HD44780 datasheet, and the above table from the 8255's datasheet,
		we can tell that the LCD's data register must be mapped to <span class="hex-address">0x2800</span>, 
		and its control register to <span class="hex-address">0x2801</span>.
		We'll go into more detail about the LCD controller itself later in the article.
	</p>

	<h3 id="wrapping_up">Wrapping Up <a class="permalink" href="#wrapping_up">#</a></h3>
	<p>
		Now we've got a pretty good idea of what's going on where in the memory map,
		and how this is discovered.
		To save you the trouble of going through the whole schematic,
		here are all the memory-mapped peripheral addresses.
		</p><table>
			<tr>
				<th>Address Range</th>
				<th>Peripheral</th>
			</tr>
				<tr><td><span class="hex-address">0x1000 - 0x2800</span></td><td>RAM (External)</td></tr>
				<tr><td><span class="hex-address">0x2800</span></td><td>LCD Data</td></tr>
				<tr><td><span class="hex-address">0x2801</span></td><td>LCD Control</td></tr>
				<tr><td><span class="hex-address">0x2802</span></td><td>Sustain/Portamento Pedals, and LCD Busy Line</td></tr>
				<tr><td><span class="hex-address">0x2803</span></td><td>8255 Peripheral Controller Control Register</td></tr>
				<tr><td><span class="hex-address">0x2804</span></td><td>OPS Mode register</td></tr>
				<tr><td><span class="hex-address">0x2805</span></td><td>OPS Algorithm/Feedback register</td></tr>
				<tr><td><span class="hex-address">0x280A</span></td><td>DAC Volume</td></tr>
				<tr><td><span class="hex-address">0x280E</span></td><td>LED1</td></tr>
				<tr><td><span class="hex-address">0x280F</span></td><td>LED2</td></tr>
				<tr><td><span class="hex-address">0x3000 - 0x4000</span></td><td>EGS</td></tr>
				<tr><td><span class="hex-address">0x4000 - 0x5000</span></td><td>Cartridge Interface</td></tr>
				<tr><td><span class="hex-address">0xC000 - 0xFFFF</span></td><td>ROM</td></tr>
		</table>
	
	<p>
		These aren't the only peripherals attached to the system,
		the Hitachi 6303 CPU also features 'IO Ports'.
		These are memory-mapped input/output lines with their own dedicated functionality.
		We'll touch on these later in the article.
	</p>

	<h2 id="disassembling_the_firmware">Disassembling The Firmware <a class="permalink" href="#disassembling_the_firmware">#</a></h2>
	<p>
		Now that we know the memory map, we can start disassembling the firmware.
		To do this we'll use a graphical disassembler called 
		<a href="https://ghidra-sre.org/" target="_blank">Ghidra</a><sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>.
		It's a relatively new player on the scene, but it's free, open source,
		and very powerful.
		A great resource to keep handy while working with Ghidra is the 
		<a href="https://ghidra-sre.org/CheatSheet.html" target="_blank">Ghidra Cheat Sheet</a>.
	</p>

	<div class="note">
		<span class="heading">Ghidra 6303 Support:</span>
		As of the time of writing,
		Ghidra doesn't yet support the HD6303 architecture out of the box,
		so we'll need to install our own language specification.
		<a href="https://github.com/blackjetrock/ghidra-6303" target="_blank">This</a>
		repository contains a Ghidra language specification for the 6303 architecture.
		To install it, 
		download the repository and copy the <code>6303</code> directory to the 
		<code>Ghidra/Processors</code> directory inside your Ghidra installation.
		You'll need to restart Ghidra to see the new processor in the list.
	</div>

	<p>
		Once you've installed the language definitions, open Ghidra and create a new project.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/new_project.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'New Project' dialog" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/new_project_thumbnail.jpg">
		</a>

		The first thing we're going to need to do is to import the firmware ROM binary.
		Select the '6303' language, and click 'OK'.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/set_language.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'Select Language' dialog" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/set_language_thumbnail.jpg">
		</a>
	</p>
	<p>
		Next, open up the <i>Codebrowser</i>.
		This is where all the action happens.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/codebrowser.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'Codebrowser' button" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/codebrowser_thumbnail.jpg">
		</a>
	</p>
	<p>
		Once the initial disassembly loads, 
		the first thing you'll be looking at is row after row of hexadecimal.
		This is the actual machine code as it would appear to the CPU.
		Don't bother with <i>analyzing</i> the file.
	</p>
	<p>
		The first thing we're going to do is set up the memory map. 
		Remember that thing we just did all that hard work figuring out?
		That's going to come in handy now.
		Press the <b>'Display Memory Map'</b> icon in the top button bar,
		to open up the Memory Map dialog.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/display_memory_map.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'Display Memory Map' button" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/display_memory_map_thumbnail.jpg">
		</a>

		By default there's only one memory block defined.
		This block consists of the binary we just imported, 
		so go ahead and rename it to <i>'ROM'</i>.
		The next thing we need to do is move this block to the correct offset <span class="hex-address">0xC000</span>.
		Because all of the machine code instructions reference memory with absolute addresses,
		if we didn't map the ROM to the correct location none of the disassembly would work.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/move_block_button.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'Move Memory Block' button" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/move_block_button_thumbnail.jpg">
		</a>

		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/move_block.png" target="_blank">
			<img alt="A screenshot of Ghidra showing the 'Move Memory Block' dialog" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/move_block_thumbnail.jpg">
		</a>
	</p>
	<p>
		Before we finish setting up the memory map,
		let's take a quick look at the code.
		When the Hitachi 6303 processor in the DX7 powers up,
		it knows where to begin executing code by fetching a pointer from a specific location in the <i>interrupt vector table</i>.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/interrupt_vectors.png" target="_blank">
			<img alt="An excerpt table from the 6301/6303 Handbook showing the 6303's interrupt vector table" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/interrupt_vectors_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt table from the 6301/6303 Handbook showing the 6303's interrupt vector table.
		</figcaption>
	</figure>
	<p>
		In this case the <i>'Reset vector'</i> is always located at the specific memory address
		<span class="hex-address">0xFFFE</span>,
		right at the end of the address space.
		Press the 
		<span class="keyboard-command">
			<span class="key">Ctrl</span><span class="plus">+</span><span class="key">End</span>
		</span> 
		combination on your keyboard to move to the end of the binary, 
		and select the offset <span class="hex-address">0xFFFE</span> 
		by clicking on it.
		Press the <span class="keyboard-command"><span class="key">P</span></span> 
		key on your keyboard to convert the data at this address to a pointer. 
		You should see something similar to the image below.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_vector_pointer.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the reset vector pointer" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_vector_pointer_thumbnail.jpg">
		</a>
	</p>
	<p>
		Double-click on this pointer to take you to the associated offset in the binary.
		Now we've found where the actual code is located, but it doesn't look like much just yet.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_location.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the reset handler function" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_location_thumbnail.jpg">
		</a>
	</p>
	<p>
		To begin disassembling the machine code into something we can work with,
		click on the label and press the 
		<span class="keyboard-command"><span class="key">D</span></span> 
		key on your keyboard,
		or right-click and select <i>'Disassemble'</i> in the context menu.
	</p>
	<div class="note">
		<span class="heading">The Reset Vector:</span>
		Different processor architectures will have different methods for locating the reset handler.
		Typically a pointer to the reset handler will be stored in an <i>interrupt vector table</i> (IVT) at a fixed location in memory.
		On an ARM Cortex-M processor the IVT is located at address <span class="hex-address">0x0</span>,
		and the reset vector at <span class="hex-address">0x4</span>.
		On the <a href="https://en.wikipedia.org/wiki/MCS-51" target="_blank">MCS-51</a> architecture 
		&#8212;another popular 8-bit microcontroller commonly seen in synthesisers&#8212;
		the actual reset <em>handler</em> begins at <span class="hex-address">0x0</span>.
	</div>
	<p>
		The disassembly process will follow the flow of code through the binary,
		disassembling as it goes.
		An error will pop up here, but don't worry about it for now.
		This is just the disassembler mistaking a jump table for code.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/analyzer_error.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the expected 'analyzer error' message" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/analyzer_error_thumbnail.jpg">
		</a>
	</p>
	<p>
		Once the disassembly completes you should see something like the picture below.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_disassembled.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the disassembled reset handler" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_handler_disassembled_thumbnail.jpg">
		</a>
	</p>
	<p>
		Now we're looking at real code! No need to panic though.
		If you don't understand what you're looking at, that's okay.
		Assembly can look pretty intimidating at first,
		but with a little bit of practice you'll get the hang of it!
	</p>
	<p>
		Each of the lines you're seeing here represents a single machine-code instruction translated into assembly code.
		The three letter <i>mnemonics</i> are the human-readable representation of the instructions.
		<span class="assembly-instruction">LDA</span>
		for example, is the mnemonic for the <i>'Load value into register A'</i> instruction.
		<span class="assembly-instruction">STA</span>
		is the mnemonic for the <i>'Store value in register A'</i> instruction.
		If you've never encountered assembly language before, that's okay!
		<a href="https://youtu.be/4gwYkEK0gOk?si=ZY9W2wwP2YZEtN7V" target="_blank">This</a>
		video will give a very quick and general introduction to assembly language.
	</p>
	<p>
		The HD63B03RP CPU used in the DX7 is a member of the
		<a href="https://www.cpushack.com/tag/6800/" target="_blank">6800</a> family of processors.
		Its instruction set (the full set of assembly <i>instructions</i>) is small and easy to understand.
		A great resource for understanding the 6303 CPU and its instruction set is the
		<i><a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">
			HD6301/HD6303 Series Handbook
		</a></i>
		freely available on bitsavers.org.
	</p>
	<p>
		The <span class="assembly-label">FUN_c5e5</span> text you're seeing here is a <i>label</i>.
		This is a symbol placed in the disassembler's 
		<a href="https://en.wikipedia.org/wiki/Symbol_table" target="_blank">symbol table</a>,
		which can be referenced elsewhere in the assembly code,
		usually as the target for a branching instruction.
		Ghidra should already have set up the reset vector as a 'function'.
		Select this label with your cursor and press the 
		<span class="keyboard-command"><span class="key">F</span></span>
		key on your keyboard to edit the function and give it a more meaningful label like 
		<span class="assembly-label">reset</span>.
	</p>
	<p>
		But what are all these red labels we're seeing, 
		like <span class="assembly-label invalid-assembly-label">DAT_2575</span>? 
		If you try to double click on it,
		Ghidra offers a helpful error message: <i>'Address not found in program memory: 2575'</i>.
		This is because we're missing our memory map!
		Let's go back to the 'Memory Map' dialog, and add the missing blocks.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/adding_ram_memory_map.png" target="_blank">
			<img alt="A screenshot showing adding the RAM memory map block in Ghidra" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/adding_ram_memory_map_thumbnail.jpg">
		</a>
	</p>
	<p>
		Fill in the memory map that we worked out in the last section.
		The completed map should look something like the screenshot below.
		You can choose to consolidate some of these blocks if you like.
		It's not super important how the blocks are divided.
		What matters is that the blocks cover all of the needed peripheral addresses.

		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/memory_map.png" target="_blank">
			<img alt="The completed memory map shown in Ghidra, with all peripheral address space allocated" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/memory_map_thumbnail.jpg">
		</a>

		Note that I added memory blocks for the HD6303 CPU's internal registers, and internal RAM.
	</p>
	<p>
		Now is a good time to go and fill in the individual peripheral addresses that we know.
		The
		<a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">HD6301/HD6303 Series Handbook</a>
		provides a list of the HD6303RP's internal registers.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/internal_register_area.png" target="_blank">
			<img alt="An excerpt from the Hitachi HD6301/HD6303 Series Handbook showing the IO port addresses" src="/static/img/articles/reverse_engineering_vintage_synths/internal_register_area_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Hitachi HD6301/HD6303 Series Handbook showing the IO port addresses.
		</figcaption>
	</figure>
	<p>
		Press the 
		<span class="keyboard-command">
			<span class="key">Ctrl</span><span class="plus">+</span><span class="key">Home</span>
		</span> 
		keys on your keyboard to go to address <span class="hex-address">0x0</span>.
		Press the <span class="keyboard-command"><span class="key">B</span></span>
		key on your keyboard to declare that address <span class="hex-address">0x0</span> specifies a byte of data.
		You'll see the <code>??</code> change to <code>db</code>,
		which is the assembler <i>directive</i> to define a byte of memory.
		Press the <span class="keyboard-command"><span class="key">L</span></span> 
		key on your keyboard to give this address a useful label like 
		<span class="assembly-label">io_port_1_dir</span>.
		Go ahead and fill in the rest of the peripherals.
		When you go back to the reset handler you'll notice that,
		even with only a few pieces of the jigsaw puzzle in place,
		things will start to make a lot more sense.
	</p>

	<h3 id="reset_function">The Reset Function <a class="permalink" href="#reset_function">#</a></h3>
	<p>
		The main reset handler in the DX7 is responsible for initialising the firmware.
		It sets up the CPU's IO ports,
		ensures the firmware's important variables have valid values,
		and sets up the CPU's <i>timer interrupt</i>.
		More on this later.
	</p>
	<div class="note">
		<span class="heading">Registers:</span>
		The 6303 has three general-purpose 
		<a href="https://en.wikipedia.org/wiki/Accumulator_(computing)" target="_blank">accumulator</a>
		registers: <span class="register-name">A</span>, <span class="register-name">B</span>, 
		and <span class="register-name">D</span>.
		<span class="register-name">A</span> and 
		<span class="register-name">B</span> are both 8-bits in size, 
		and <span class="register-name">D</span> provides a 16-bit view of both of them combined: 
		<code>D == (A &lt;&lt; 8) | B</code>.
	</div>
	<p>
		A great way to visualise the <i>'control flow'</i> of the program is in the 
		<i>'Function Graph'</i> view.
		This view shows a directed graph of the program's branching logic.
		You can open this view by selecting <b>Window &#8594; Function Graph</b> in the top window menu.
		You should see a view similar to the picture below.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_function_graph.png" target="_blank">
			<img alt="A screenshot of Ghidra's function graph of the reset handler" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/reset_function_graph_thumbnail.jpg">
		</a>
		At offset <span class="hex-address">0xC605</span> you'll see the following instructions:
	</p>
	<div class="code-block"><pre><span></span><span class="k">LDA</span><span class="w">   </span><span class="p">#</span><span class="mi">0</span><span class="n">xd</span>
<span class="n">CMPA</span><span class="w">  </span><span class="n">DAT_2328</span>
<span class="n">BHI</span><span class="w">   </span><span class="n">LAB_c60f</span>
</pre></div>
	<ol class="disassembly-writeup">
		<li>
			The <span class="assembly-instruction">LDA</span> instruction loads the <i>immediate</i> 
			value <code>0xD</code> into the <span class="register-name">A</span> register.
		</li>
		<li>
			The <span class="assembly-instruction">CMPA</span> 
			instruction then compares the value in the <span class="register-name">A</span> 
			register with the value at the memory address 
			<span class="assembly-label">DAT_2328</span>.
		</li>
		<li>
			The <span class="assembly-instruction">BHI</span> instruction tells the CPU to branch to the label 
			<span class="assembly-label">LAB_c60f</span>
			if the value in the <span class="register-name">A</span> 
			register is greater than the value at 
			<span class="assembly-label">DAT_2328</span>.
		</li>
	</ol>
	<div class="note">
		<span class="heading">Condition Codes:</span>
		What <em>actually</em> happens when you execute a <span class="assembly-instruction">CMPA</span>
		instruction is that the CPU sets a series of fields in the 
		<i>'condition code'</i> register based on the result of the comparison.
		These <i>'condition codes'</i> 
		are used by the conditional branching instructions to determine whether or not to take the branch.
		In this case, the <span class="assembly-instruction">BHI</span> 
		instruction will take the branch if the <i>C(arry)</i> and <i>Z(ero)</i> 
		condition codes are both clear.
	</div>
	<p>
		You can see in the function graph that if the memory at 
		<span class="assembly-label">DAT_2328</span> 
		is greater than or equal to '13',
		it will not branch, and the value will be cleared. 
		The program will then continue to execute the next instruction, 
		which would have been the original branch target.
		In this case, the program is checking to see that the 'pitch bend range' variable 
		(stored in memory at location <span class="hex-address">0x2328</span>)
		is within a valid range of 0-12.
		If not, it's reset to 0.
	</p>
	<p>
		If you look down at the bottom of the graph, you'll notice something interesting:
		The program goes into an infinite loop. 
		This is the firmware's <i>'main loop'</i>.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/main_loop.png" target="_blank">
			<img alt="The firmware's 'main loop'" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/main_loop_thumbnail.jpg">
		</a>
		Tasks that need to be performed continuously happen here.
		Such as updating the UI based on user input,
		and parsing incoming MIDI messages.
	</p>
	<p>
		When certain tasks not only need to be performed <i>continuously</i>, but also <i>periodically</i>,
		there's another way to make this happen: <i>interrupts</i>.
	</p>
	<h3 id="interrupts">Interrupts <a class="permalink" href="#interrupts">#</a></h3>
	<p>
		<a href="https://en.wikipedia.org/wiki/Interrupt" target="_blank">Interrupts</a>
		are signals sent to the processor by hardware or software to 
		<em>interrupt</em> the current code being executed, and handle a specific event.
		They're commonly used in embedded-software to handle external,
		time-critical, or asynchronous events.
	</p>
	<p>
		One of the most common types of interrupt you'll encounter is a 
		<a href="https://www.visualmicro.com/page/Timer-Interrupts-Explained.aspx" target="_blank"><i>'timer interrupt'</i></a>.
		The HD6303's built-in timer interrupt consists of a 16-bit <i>'counter'</i> register, 
		which is incremented every clock cycle, 
		and a 16-bit <i>'output compare'</i> register.
		When the value in the counter register matches the value in the output compare register, 
		a timer interrupt will be raised.
		This causes the processor to halt what it was doing, 
		push the current state of the CPU onto the stack, 
		and jump to the appropriate interrupt handler specified in the interrupt vector table.
		In the 6303 a pointer to this handler is located at offset <span class="hex-address">0xFFF4</span>.
		Once the firmware is done handling the interrupt,
		it executes the <span class="assembly-instruction">RTI</span> instruction,
		which restores the CPU's state from the stack and continues executing the code from where it left off.
	</p>
	<p>
		The timer interrupt handler is where all the synth's <i>real-time</i> functionality happens.
		This is any code that needs to be executed in a time-critical manner.
		The DX7 uses the periodic timer interrupt to process portamento and modulation, 
		update the individual voice frequencies, and send the updated voice data to the sound chips.
		Feel free to declare the pointer to the timer interrupt handler just like we did for the reset handler, 
		disassemble the handler, and take a look at what's going on.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/ocf_handler.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the interrupt vector table and the OCF interrupt handler pointer" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/ocf_handler_thumbnail.jpg">
		</a>
	</p>
	<h3 id="lcd_interface">LCD Interface <a class="permalink" href="#lcd_interface">#</a></h3>
	<p>
		One of the best places to start reverse-engineering a synth's firmware is to understand how it prints things to the LCD screen.
		We already know <em>where</em> the LCD controller is mapped in memory,
		let's work backwards from there and see if we can find that code.
	</p>
	<p>
		Press the <span class="keyboard-command"><span class="key">G</span></span> 
		key on your keyboard to open the <i>'Go To...'</i> dialog,
		and go to address <span class="hex-address">0x2800</span>.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_registers.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the LCD registers" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_registers_thumbnail.jpg">
		</a>
		These are the two memory-mapped LCD registers.
		The list of <i>cross-references</i> 
		on the right shows us where these addresses are referenced in the code.
		Click on the <span class="assembly-label">FUN_fdef</span> label to take us to this function.
		This is the function called by the reset handler to initialise the LCD screen.
	</p>
	<p>
		Below the function we can see something that looks like ASCII data.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/welcome_message.png" target="_blank">
			<img alt="Screenshot from Ghidra showing ASCII data embedded in the code" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/welcome_message_thumbnail.jpg">
		</a>
		In fact, it looks a lot like the welcome message displayed when you boot up the DX7. Hmm.
		Click on offset <span class="hex-address">0xFE31</span>, and press the 
		<span class="keyboard-command"><span class="key">'</span></span> key on the keyboard twice.
		Once to convert the data at this offset to character data,
		twice to convert it to a NULL-terminated string.
	</p>
	<p>
		Notice that the welcome message location is referenced in the code at offset
		<span class="hex-address">0xFE2B</span>:
	</p>
	<div class="code-block"><pre><span></span><span class="k">JSR</span><span class="w">   </span><span class="n">FUN_fe52</span>
<span class="k">LDX</span><span class="w">   </span><span class="p">#</span><span class="mi">0</span><span class="n">xfe31</span>
<span class="k">JMP</span><span class="w">   </span><span class="n">FUN_fea4</span>
</pre></div>
	<p>
		Select the operand <code>#0xFe31</code>, and press 
		<span class="keyboard-command">
			<span class="key">Alt</span><span class="plus">+</span><span class="key">Ctrl</span><span class="plus">+</span><span class="key">R</span>
		</span>
		on your keyboard to turn this into a
		<i>memory reference</i>.
		The default label looks a bit strange, so you might want to give it a better one like
		<span class="assembly-label">str_welcome_message</span>
		by selecting the reference and pressing the 
		<span class="keyboard-command"><span class="key">L</span></span> key.
	</p>
	<p>
		We can see here that a pointer to the welcome message string is loaded into the <span class="register-name">X</span> register,
		and then the ROM jumps to the function <span class="assembly-label">FUN_fea4</span>.
		Could this function have something to do with printing the string? Let's find out.
	</p>
	<div class="note">
		<span class="heading">The Index Register (X):</span>
		The Motorola 6800 family of processors has an interesting feature called an 
		<a href="https://en.wikipedia.org/wiki/Index_register" target="_blank"><i>'index register'</i></a>.
		The index register (<span class="register-name">X</span>) can be used as a 16-bit base address, 
		to which an 8-bit relative offset can be applied.
		For example,
		the <code>LDA 4,x</code> instruction will load the byte into
		<span class="register-name">A</span> that is 4 bytes from the address stored in
		<span class="register-name">X</span>.
		This is useful because it allows us to reference 16-bit addresses with only an 8-bit operand.
	</div>
	<p>
		Let's take a walk through <span class="assembly-label">FUN_fea4</span> 
		together and see if we can figure out what it's doing:
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_and_update.png" target="_blank">
			<img alt="Screenshot from Ghidra showing an unknown function that prints the welcome message to the LCD screen" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_and_update_thumbnail.jpg">
		</a>
	</p>
	<ol class="disassembly-writeup">
		<li>
			First, it pushes the address of the welcome message string in 
			<span class="register-name">X</span> to the stack.
		</li>
		<li>
			Then it loads a memory address (<span class="hex-address">0x261F</span>)
			into <span class="register-name">X</span>, 
			and saves that address to a pointer in memory.
		</li>
		<li>
			Then it restores the welcome message address from the stack into
			<span class="register-name">X</span>.
		</li>
	</ol>
	<p>
		Not very helpful yet, unfortunately.
		Something I find that helps make sense of so many unknown labels is to give them names that describe how they're used.
		Double-click on the label <span class="assembly-label">DAT_00fb</span> to go to its location.
		Since we know this variable stores memory addresses,
		press the <span class="keyboard-command"><span class="key">P</span></span> 
		key to convert it to a pointer.
		Giving it a name like <span class="assembly-label">unknown_lcd_pointer_00fb</span>
		can help identify it at a glance later.
	</p>
	<p>
		Use the 
		<span class="keyboard-command">
			<span class="key">Alt</span><span class="plus">+</span><span class="key">&#8592;</span>
		</span> 
		keyboard combination to navigate back to where we were before.
		Once you're there, click through to <span class="assembly-label">FUN_fe8b</span>.

		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_strcpy.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the function located at 0xfe8b" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_strcpy_thumbnail.jpg">
		</a>

		We can see that lots of cross-references to this function have been found in the code already.
		Let's go through this function step by step and see what we can figure out:
	</p>
	<ol class="disassembly-writeup">
		<li>
			We already know that the <span class="register-name">X</span> register contains a pointer to a string.
			So we can see that this function is loading an ASCII character into register <span class="register-name">B</span>
			from the address stored in <span class="register-name">X</span>.
		</li>
		<li>
				When the <span class="assembly-instruction">LDB</span>
				instruction loads a new value into <span class="register-name">B</span>
				it sets the <i>condition codes</i> according to its value.
				If the most-significant bit of this byte is 1, the <i>N(egative)</i> condition code will be set.
				This will cause the <span class="assembly-instruction">BMI</span>
				(<i><b>B</b>ranch If <b>MI</b>nus</i>) instruction to branch.
				Valid 
				<a href="https://www.asciitable.com/" target="_blank">ASCII</a>
				values fall within the range 0-127, so this code looks like it's checking for an invalid character,
				and will branch to the exit if this is the case.<br>
				<b>Note:</b> Different instructions treat integer values as either signed, or unsigned,
				with the most-significant bit treated as the 
				<a href="https://en.wikipedia.org/wiki/Sign_bit" target="_blank">sign bit</a>.
		</li>
		<li>
			The value in <span class="register-name">B</span> 
			is then compared against <code>0x20</code> (ASCII space).
			As I mentioned earlier, the <span class="assembly-instruction">CMP</span> instruction
			sets condition codes according to the value in the associated accumulator, and the operand.
			The <span class="assembly-instruction">BCC</span> instruction
			(<i><b>B</b>ranch If <b>C</b>arry <b>C</b>lear</i>) 
			will branch if the <i>C(arry)</i> condition code is <em>clear</em>.
			This means that the value in <span class="register-name">B</span> 
			must be <code>0x20</code> or above,
			otherwise the function exits.<br>

			You can read more about how the carry flag is used in computer arithmetic on
			<a href="https://en.wikipedia.org/wiki/Carry_flag" target="_blank">Wikipedia</a>.
		</li>
		<li>
			If the ASCII char is valid, it calls <span class="assembly-instruction">BSR</span> 
			to branch to the subroutine <span class="assembly-label">FUN_fe9a</span>.
			In this subroutine we can immediately see something interesting:
			Remember that pointer we labeled earlier? 
			This subroutine writes the ASCII character in <span class="register-name">B</span>
			to the location in this pointer, increments the pointer, and saves it...
		</li>
		<li>
			After this, 
			the address in <span class="register-name">X</span> is incremented,
			and the function loops back to the start.
			Now the function repeats, 
			with <span class="register-name">X</span> pointing to the <em>next</em> character in the string.
		</li>
	</ol>
	<p>
		Are you thinking what I'm thinking? This is a <em>String Copy</em> function!
		It copies characters from a string into a buffer, 
		until either a NULL-terminator, or other unprintable ASCII character is encountered.
	</p>
	<p>
		Go ahead and give this function a label like <span class="assembly-label">lcd_strcpy</span>.
		If you like, you can apply local labels to <span class="assembly-label">LAB_fe94</span>, 
		and <span class="assembly-label">LAB_fe99</span> like 
		<span class="assembly-label">.copy_character</span> and <span class="assembly-label">.exit</span>.
		Maybe give that buffer address we saw earlier (<span class="hex-address">0x261F</span>) a temporary label too.
	</p>
	<div class="note">
		<span class="heading">Subroutines:</span>
		You might have noticed the instructions 
		<span class="assembly-instruction">BSR</span>
		(<i>'<b>B</b>ranch to <b>S</b>ub<b>R</b>outine'</i>), or <span class="assembly-instruction">JSR</span>
		(<i>'<b>J</b>ump to <b>S</b>ub<b>R</b>outine'</i>).
		These instructions are used to call <i>subroutines</i>.
		When a subroutine is <i>called</i>,
		the address of the next instruction is pushed onto the stack,
		and the 
		<a href="https://en.wikipedia.org/wiki/Program_counter" target="_blank"><i>'program counter'</i></a>
		jumps to the address of the subroutine.
		When the subroutine calls the <span class="assembly-instruction">RTS</span>
		instruction to <i>return</i> to its caller,
		this address is popped from the stack into the 
		<span class="register-name">PC</span> (Program Counter) register,
		and the program continues from where it left off.
		Just like a function call in a higher-level language.
	</div>
	<p>
		This is where we're at so far:
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_function_partially_annotated.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the function located at 0xfea4 partially annotated" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_function_partially_annotated_thumbnail.jpg">
		</a>
	</p>
	<p>
		Let's move on to that last function <span class="assembly-label">FUN_fe52</span> and see where that leads us.
		This function is a bit more complicated.
		Using the <i>Function Graph</i> window I showed you before might help visualise what's going on.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_update.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the function graph of the function located at 0xfe52" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_update_thumbnail.jpg">
		</a>
		Let's go through this function step-by-step like we did before:
	</p>
	<ol class="disassembly-writeup">
		<li>
			A new location in memory (<span class="hex-address">0x263F</span>) 
			is being saved to that pointer we saw before,
			and the LCD buffer address we saw earlier (<span class="hex-address">0x261F</span>)
			is being saved to a new pointer.
			There's something interesting about those addresses.
			They're 32 bytes apart. That seems a bit conspicuous, doesn't it?
			Maybe this corresponds to the length of the LCD screen (2 lines of 16 characters)?
		</li>
		<li>
			A constant value is loaded into <span class="register-name">B</span>.
		</li>
		<li>
			Inside the loop, we can see that <span class="register-name">B</span> is saved to the stack.
			A byte is then loaded into <span class="register-name">A</span>
			from the location in the pointer at <span class="hex-address">0xF9</span>.
			We know from seeing the welcome message string loaded into <span class="register-name">X</span> 
			that this byte is ASCII string data.
			The pointer is then incremented and saved.
		</li>
		<li>
			This byte is then compared against the byte pointed to by <span class="assembly-label">unknown_lcd_pointer_00fb</span>.
		</li>
		<li>
			If the character in <span class="assembly-label">unknown_lcd_pointer_00f9</span>
			and <span class="assembly-label">unknown_lcd_pointer_00fb</span> <em>aren't</em> equal,
			then this character is used as an argument for a function call to <span class="assembly-label">FUN_fec7</span>.
		</li>
	</ol>
	<p>
		The function at <span class="assembly-label">FUN_fec7</span> is a bit more complicated,
		so I'll walk you through what's happening.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_instruction.png" target="_blank">
			<img alt="The firmware's 'main loop'" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_instruction_thumbnail.jpg">
		</a>
	</p>

	<ol class="disassembly-writeup">
		<li>
			The constant <code>0x89</code> is written to the 8255 PPI control register at <span class="hex-address">0x2803</span>.
			The PPI datasheet refers to this as <i>'Control Word #5'</i>.
			This sets the PPI's Port A, and B to outputs,
			allowing the CPU to send data to the LCD controller.
		</li>
		<li>
			A value of zero is written to the LCD control register.
			This sets the <code>RS</code> line low to select the <i>Instruction Register</i>,
			and the <code>RW</code> line low to select a <i>Write</i> operation.
		</li>
		<li>
			The <code>E</code> line of the LCD is then driven high to instruct it to be ready to receive data over the data bus.
		</li>
		<li>
			The byte in <span class="register-name">A</span> is then written to the LCD instruction register.
			After this, the <code>E</code> line is driven low, and the 
			<code>RW</code> line is driven high to signal the end of the data transfer.
		</li>
		<li>
			The 8255 <i>'Control Word #13'</i> is written to the PPI control register to revert port A and C to being inputs.
		</li>
		<li>
			Finally, it branches unconditionally to <span class="assembly-label">FUN_ff08</span>.
		</li>
	</ol>

	<div class="note">
		<span class="heading">Note about unconditional branches:</span> 
		Sometimes, rather than returning with an
		<span class="assembly-instruction">RTS</span> instruction,
		a subroutine will just unconditionally branch to the next subroutine.
		As long as the stack is managed correctly, this is perfectly valid.
		The second subroutine's ending <span class="assembly-instruction">RTS</span> 
		instruction will just pop the original return value from the stack and return to the original caller.
		This technique saves a few bytes of code.
	</div>

	<p>
		Let's check out the subroutine at <span class="assembly-label">FUN_ff08</span> that our function jumps to.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_wait_ready.png" target="_blank">
			<img alt="A screenshot from Ghidra showing the subroutine at 0xFF08." src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_wait_ready_thumbnail.jpg">
		</a>
	</p>
	<ol class="disassembly-writeup">
		<li>
			The <code>E</code> and <code>RW</code> lines of the LCD controller are set high.
			This sets the LCD controller to read mode.
		</li>
		<li>
			The PPI's port C is read into the <span class="register-name">A</span> register,
			then the <code>E</code> line of the LCD controller is set low to indicate the read operation is complete.
		</li>
		<li>
			A bitwise <code>AND</code> is performed between value of the 
			<span class="register-name">A</span> register and <code>0b1000_0000</code>.
			This checks the status of the <code>PC7</code> line.
			If the <code>PC7</code> line is high,
			the function loops back to the start.
		</li>
	</ol>
	<p>
		It's easy to miss, 
		but if you look closely in the schematics you'll see that the PPI's <code>PC7</code> line is connected to <code>PA7</code>,
		which is connected to the LCD controller's DB7 pin.
		<a href="/static/img/articles/reverse_engineering_vintage_synths/schematics/lcd_busy_line.png" target="_blank">
			<img alt="An excerpt from the Yamaha DX7's schematics showing the PPI's connection to the LCD controller's 'Busy Flag' line" src="/static/img/articles/reverse_engineering_vintage_synths/schematics/lcd_busy_line_thumbnail.jpg">
		</a>
		The DB7 pin serves as the LCD controller's <i>'Busy Flag'</i>.
		This flag indicates whether the LCD controller is busy processing data.
		When it's clear, the LCD controller is ready to accept new data.
	</p>
	<p>
		It looks like the purpose of this function is to poll the LCD controller, 
		waiting for it to be ready to accept new data. Awesome!
		Let's give it a label like <span class="assembly-label">lcd_wait_ready</span>.
		Okay! So putting it all together,
		the function at <span class="hex-address">0xFEC7</span> 
		writes an <em>instruction</em> to the LCD controller,
		and then waits for it to be ready to receive data again.
		Go ahead and give it a name like <span class="assembly-label">lcd_write_instruction</span>.
	</p>
	<p>
		Reverse-engineering often involves going down a rabbit hole.
		Sometimes you need to fill in a few different pieces of the puzzle before you can start to see the whole picture.
		Let's return to the function at <span class="assembly-label">FUN_fe52</span> and see what happens next.
	</p>
	<p>
		We now know the loop is writing an instruction to the LCD controller,
		but what did this instruction do?
		The original instruction value when the function started was <code>0x80</code>, 
		and it's incremented by one with each iteration of the loop.
		The HD44780 datasheet tells us that <code>0x80</code> 
		is the instruction to set the DDRAM  (Display Data RAM) address in the LCD controller.
		This is the address in the LCD's memory where the next character will be written.
		A value of <code>0x80</code> indicates the start of the screen's first line.
	</p>
	<p>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_data.png" target="_blank">
			<img alt="The firmware's 'main loop'" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_write_data_thumbnail.jpg">
		</a>
		The next function call (<span class="assembly-label">FUN_fee7</span>) looks almost identical to our
		<span class="assembly-label">lcd_write_instruction</span> function.
		The only difference is that it writes to the LCD controller's <em>data</em> register,
		rather than the instruction register.
		This must be where the actual character data is written!
		You can give this function a label like <span class="assembly-label">lcd_write_data</span>.
		Note that this function <i>'falls-through'</i> to the LCD controller polling function we saw earlier.
	</p>
	<p>
		Now we know what's going on here.
		This is our LCD printing function!
		Notice that after writing the character data to the LCD,
		at offset <span class="hex-address">0xFE77</span> the function writes it to the buffer at 
		<span class="hex-address">0x263F</span>?
		The incoming characters are compared against the contents of this buffer to see if they're identical,
		if they are then it skips printing the character.
		Maybe these buffers represent the <i>'next'</i>, and <i>'current'</i> contents of the LCD screen?
	</p>
	<p>
		After writing the LCD character data, 
		the function then checks whether the LCD instruction byte is equal to <code>0xD0</code>.
		Now we know that this is checking whether the LCD DDRAM position is at the end of the second line.
		If not, it checks whether we're at the end of the first line (<code>0x90</code>).
		If so, the instruction byte is set to <code>0xC0</code>, which sets the DDRAM address to the start of the second line.
	</p>
	<div class="note">
		<span class="heading">Note about HD44780 DDRAM addresses:</span>
		Each 'line' in the HD44780 LCD controller actually has a length of 64 characters,
		even if the screen is only 16 characters wide.
		As a result, <code>0xC0</code> (<code>0x80 + 0x40</code>) 
		is the correct DDRAM address for the start of the second line.
	</div>
	<p>
		Awesome! Now we've discovered the LCD printing function!
		Go ahead and give it a name like <span class="assembly-label">lcd_print</span>.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_print.png" target="_blank">
			<img alt="The firmware's 'main loop'" src="/static/img/articles/reverse_engineering_vintage_synths/disassembly/lcd_print_thumbnail.jpg">
		</a>
		<figcaption>
			The completed <code>lcd_print</code> function.
			Note that I went ahead and labelled all of the important variables.
		</figcaption>
	</figure>
	<p>
		If you've followed along,
		give yourself a huge pat on the back.
		This was no easy feat!
		You've now got a pretty good understanding of how vintage synth binaries are reverse-engineered.
		Everything else involved in disassembling a synth's firmware is just a matter of applying these same ideas.
	</p>

	<div class="note">
		<span class="heading">Bonus:</span> 
		The HD44780 LCD controller has been a staple in consumer devices for
		<em>decades</em><sup><a href="#footnote_5" id="footnote_5_link">5</a></sup>.
		LCD controllers compatible with the HD44780 instruction set are still being manufactured, 
		and are commonly used in commercial, and hobby projects alike.
		Because of this, lots of tutorial material is available online, 
		and the knowledge gained in working with it is applicable elsewhere.
	</div>

	<h2 id="going_further">Going Further <a class="permalink" href="#going_further">#</a></h2>

	<h3 id="midi_handling_routine">The MIDI Handling Routine <a class="permalink" href="#midi_handling_routine">#</a></h3>
	<p>
		After disassembling the LCD printing function,
		the next best way to figure out what's going on inside a synth ROM is to disassemble the function that parses incoming MIDI data.
		This function is an entry point to nearly every aspect of a synth's functionality.
		Disassembling it will allow you to trace the path of a particular MIDI message to its associated functionality.
		You can trace <i>'NOTE ON'</i> and <i>'NOTE OFF'</i> 
		messages to find the code that handles starting and stopping individual voices;
		Or you can trace <i>'CONTROL CHANGE'</i> messages to find the code that handles pitch bend or modulation.
	</p>
	<p>
		I decided not to tackle this function in this article,
		as the DX7's MIDI parsing code is huge, and requires a lot of explanation.
		Parsing MIDI messages is always implemented via a straightforward state machine,
		and the code is nearly identical across different synths.
		Once you've seen how it works in one synth, 
		you've seen how it works in nearly all of them.
	</p>

	<h3 id="debugging_the_firmware">Debugging the Firmware in an Emulator <a class="permalink" href="#debugging_the_firmware">#</a></h3>
	<p>
		One of the best ways to understand what's going on inside a synth's firmware is to run it in an emulator.
		The <a href="https://www.mamedev.org/" target="_blank">MAME</a>
		emulation framework is freely available, and already supports a wide variety of vintage synths.
		It features a built-in disassembler, 
		and a debugger that can be used to step through the firmware instruction by instruction to see what's happening in detail.
		When I was working on my
		<a href="https://github.com/ajxs/yamaha_dx97" target="_blank">Yamaha DX9/7</a>
		project, I used MAME as a testing and development platform for the firmware.
	</p>

	<h3 id="final_words">Final Words <a class="permalink" href="#final_words">#</a></h3>
	<p>
		The DX7, and its 8-bit CPU might be a bit primitive by today's standards,
		but the same principles apply to reverse-engineering modern devices.
		Instructions sets and 
		<a href="https://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling-conventions</a>
		might change, but whether it's a vintage 8-bit architecture like the 6800,
		or a cutting-edge 32-bit ARM system, 
		the principles of how to disassemble device firmware remain the same.
	</p>
	<p>
		If you have any questions about this article,
		please get in touch!
		If you have any corrections or suggestions, I'd love to hear from you.
		Thank you for reading!
	</p>

	<h2 id="why_the_dx7">Appendix: Why Choose This Synth? <a class="permalink" href="#why_the_dx7">#</a></h2>
	<h3>It Can Be Disassembled With Free Software</h3>
	<p>
		6303 binaries can be disassembled by using free and open source tools, 
		such as <a href="https://ghidra-sre.org/" target="_blank">Ghidra</a>,
		<a href="https://github.com/Arakula/f9dasm" target="_blank">F9DASM</a>,
		and MAME's
		<a href="https://www.mameworld.info/easyemu/mameguide/tools/unidasm.html" target="_blank">Universal Disassembler</a>.
	</p>

	<h3>It's Well Documented</h3>
	<p>
		40 years on, the DX7 continues to captivate people's imaginations.
		As a result, lots is known about what goes on inside a DX7.
		Yamaha's service manuals are comprehensive, and freely available online.
	</p>
	<p>
		Yamaha even released internal documentation on the DX7's architecture and sound chips,
		which is now
		<a href="/blog/Yamaha_DX7_Official_Technical_Analysis.html" target="_blank">available online</a>.
	</p>

	<h3>Only One ROM</h3>
	<p>
		One advantage of reverse-engineering the DX7 is that there's only one ROM you need worry about.
		<em>Technically</em> there's also the sub-CPU and its mask ROM,
		but in this case you don't <em>really</em> need to worry what's going on there.
	</p>
	<p>
		Some synths have important part of the firmware stored on the CPU's mask ROM, 
		such as the Casio CZ-101.
		Other synths spread the synth's core functionality across multiple CPUs, 
		each with their own ROMs, such as the Roland JX-8P.
		The DX7 is much simpler, having (nearly) all of its code in one place.
	</p>

	<h3>It Has an LCD Screen</h3>
	<p>
		Disassembling code for a system with a text-based user interface has a lot of advantages.
		I considered some of the early DCO-based Roland polysynths as candidates for this article,
		but without an LCD screen it's much harder to make headway into a ROM.
	</p>

	<h3>No Bank Switching</h3>
	<p>
		Unfortunately the various disassembler tools available don't handle
		<a href="https://en.wikipedia.org/wiki/Bank_switching" target="_blank"><i>bank switching</i></a>
		very well.
		In Ghidra you can use 'Overlay' memory blocks to set up the different banks,
		however it's still not very intuitive in my experience.
	</p>
	<p>
		I considered the Ensoniq ESQ-1 as a candidate for this article.
		It features a Motorola MC6809 processor, 
		which is very well supported by lots of different debuggers.
		However it uses bank switching, 
		which makes it a bit of a nuisance to disassemble.
	</p>

	<h4>What Is Bank Switching?</h4>
	<p>
		What happens if you need to squeeze 64KiB of firmware ROM, 
		and 32KiB of RAM into your HD6303 chip's 16-bit address space?
		One solution to this problem is <i>bank switching</i>.
		Many vintage synths use bank-switching to fit their firmware into the CPU's address space.
	</p>
	<p>
		Bank switching breaks a memory device's address space up into multiple <i>'banks'</i>
		by latching one or more of its address lines to one of the CPU's I/O port lines.
		This allows the CPU to select which 'bank' is active by toggling the aforementioned I/O line in the software.
	</p>
	<figure>
		<a href="/static/img/articles/reverse_engineering_vintage_synths/tx81z_schematics_excerpt.png" target="_blank">
			<img alt="Yamaha TX81Z schematics excerpt showing CPU, ROM, and RAM" src="/static/img/articles/reverse_engineering_vintage_synths/tx81z_schematics_excerpt_thumbnail.jpg">
		</a>
		<figcaption>
			An excerpt from the Yamaha TX81Z's schematics, showing the CPU, ROM, and RAM wiring.
		</figcaption>
	</figure>
	<p>
		The Yamaha TX81Z features a 64KiB 27C512 EPROM chip,
		mapped into the CPU's address space at <span class="hex-address">0x8000 - 0xFFFF</span>.
		The EPROM's A0-A14 pins are wired to the CPU's A0-A14,
		and the EPROM's <code class="active-low">CE1</code> pin is latched to the CPU's A15 pin.
		The EPROM's A15 pin is wired to the CPU's I/O port 6 (pin <code>P63</code> in the schematics).

		If the <code>P63</code> I/O line is pulled <em>high</em>, 
		the upper half of the EPROM's memory is selected,
		mapping addresses <span class="hex-address">0x8000 - 0xFFFF</span> into the CPU's address space.
		If it's pulled <em>low</em>, 
		the EPROM's <span class="hex-address">0x0000 to 0x7FFF</span> memory is mapped to <span class="hex-address">0x8000 - 0xFFFF</span>.
	</p>
	<p>
		To allow branching from code in one bank to code in another, 
		a common technique is to use a 
		<i><a href="https://en.wikipedia.org/wiki/Trampoline_(computing)" target="_blank">'trampoline function'</a></i>
		located at the same address in both banks.
	</p>

	<h2 id="documentation">Appendix: Documentation <a class="permalink" href="#documentation">#</a></h2>
	<p>
		Below is a list of all the important documentation referenced in the article.
		</p><ul>
			<li>
				<a href="https://yamahamusicians.com/forum/viewtopic.php?p=90769#p90769" target="_blank">
					DX7 Schematic
				</a>
			</li>
			<li>
				<a href="https://homepages.abdn.ac.uk/d.j.benson/pages/dx7/manuals/dx7-9_service_manual_1.pdf" target="_blank">
					DX7 Service Manual
				</a>
			</li>
			<li>
				<a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63667/HITACHI/HD6303R.html" target="_blank">
					Hitachi HD6303R Datasheet
				</a>
			</li>
			<li>
				<a href="http://www.bitsavers.org/components/hitachi/_dataBooks/1989_U07_HD6301_HD6303_Series_Handbook_1989.pdf" target="_blank">
					HD6301/HD6303 Series Handbook
				</a>
			</li>
			<li>
				<a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf" target="_blank">
					Hitachi HD44780 Datasheet
				</a>
			</li>
			<li>
				<a href="https://www.alldatasheet.com/datasheet-pdf/pdf/66100/INTEL/8255A.html" target="_blank">
					Intel 8255 Datasheet
				</a>
			</li>
			<li>
				<a href="https://www.ti.com/product/SN74LS138#tech-docs" target="_blank">
					74LS138 Datasheet
				</a>
			</li>
		</ul>
	
	<hr>
	<ol class="footnotes">
		<li id="footnote_1">
			The Hitachi 6303 microcontroller used in the DX7 includes both an 
			<i>internal</i>, and <i>external</i> memory bus.
			The first 256 memory addresses in the 6303 point to the CPU's internal registers and on-board RAM.
			Many modern microcontrollers &#8212;such as the Atmel AVR, and Microchip PIC series&#8212; don't feature external address buses.
			It's more common for modern microcontrollers to communicate with peripheral devices over serial buses,
			using protocols such as SPI, or I<sup>2</sup>C.
		<a href="#footnote_1_link">&#8626;</a></li><li id="footnote_2">
			On boot, the <a href="https://en.wikipedia.org/wiki/Motorola_6800" target="_blank">6800</a>
			CPU family fetches the <i>reset vector</i> from the fixed address of <span class="hex-address">0xFFFE</span>.
			Knowing this, we could have just made an educated guess that the whole ROM was mapped to the high addresses.
			Still, it's always good to check your assumptions!
		<a href="#footnote_2_link">&#8626;</a></li><li id="footnote_3">
			If you're curious about why the 8255 PPI chip is used here,
			it's most likely because the LCD controller, cartridge, 
			and portamento/sustain pedal interface don't feature a chip select interface.
		<a href="#footnote_3_link">&#8626;</a></li><li id="footnote_4">
			There are a variety of disassemblers available for the HD6303 architecture.
			The state-of-the-art graphical disassembler is arguably
			<a href="https://hex-rays.com/IDA-pro/" target="_blank">IDA Pro</a>,
			but it's closed source, and prohibitively expensive for hobbyists.
			Non-graphical disassemblers also exist, such as
			<a href="https://github.com/Arakula/f9dasm" target="_blank">F9DASM</a>.
			If you're new to reverse-engineering, I'd personally recommend starting with Ghidra.
			It's free, open source, and easy to learn.
		<a href="#footnote_4_link">&#8626;</a></li><li id="footnote_5">
			I went down a bit of a rabbit-hole trying to find what year the LM016/HD44780 was first manufactured.
			The earliest reference I can find online is a
			<a href="https://archive.org/details/Hitachi-DotMarixLiquidCrystalDisplayControllerandDriverLCD-IIHD44780UsersManualOCR/page/n1/mode/2up" target="_blank">'preliminary' user's manual</a>,
			dated March 1981.
			It's a shame that there's so little background information available about one of the best-known ICs in history.
		<a href="#footnote_5_link">&#8626;</a></li></ol>
	</div>
</article>

		<footer>
			© 2024 AJXS
		</footer>
	</body>
</html>
